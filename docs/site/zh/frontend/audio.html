<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>音频处理 - MiniCPM-o 4.5 文档</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
<style>
* { margin:0; padding:0; box-sizing:border-box; }
:root {
  --sidebar-w: 260px;
  --bg: #fff; --bg-side: #f8f9fa; --bg-code: #f6f8fa;
  --c1: #24292f; --c2: #57606a;
  --border: #d0d7de; --accent: #0969da; --nav-active: #ddf4ff;
}
body { font-family: -apple-system,BlinkMacSystemFont,"Segoe UI","Noto Sans",Helvetica,Arial,sans-serif; color:var(--c1); line-height:1.6; background:var(--bg); }
.sidebar-toggle { position:fixed; top:12px; left:12px; z-index:1001; background:var(--bg-side); border:1px solid var(--border); border-radius:6px; padding:6px 10px; font-size:18px; cursor:pointer; display:none; }
.sidebar { position:fixed; top:0; left:0; width:var(--sidebar-w); height:100vh; overflow-y:auto; background:var(--bg-side); border-right:1px solid var(--border); padding:20px 0; z-index:1000; transition:transform .3s; }
.sidebar-header { padding:0 20px 16px; border-bottom:1px solid var(--border); margin-bottom:8px; }
.sidebar-header h2 { font-size:16px; font-weight:600; }
.sidebar-subtitle { font-size:12px; color:var(--c2); }
.lang-switch { display:inline-block; margin-top:6px; font-size:12px; color:var(--accent); text-decoration:none; padding:2px 8px; border:1px solid var(--border); border-radius:4px; transition:background .15s; }
.lang-switch:hover { background:var(--nav-active); text-decoration:none; }

.nav-list { list-style:none; padding:0 8px; }
.nav-list > li > a { display:block; padding:7px 12px; color:var(--c2); text-decoration:none; font-size:14px; border-radius:6px; transition:background .15s,color .15s; }
.nav-list > li > a:hover { background:#e8e8e8; color:var(--c1); }
.nav-list > li > a.active { background:var(--nav-active); color:var(--accent); font-weight:600; }

.nav-group { margin-top:4px; }
.nav-group-header { display:flex; align-items:center; gap:6px; padding:8px 12px; color:var(--c1); font-size:12px; font-weight:700; text-transform:uppercase; letter-spacing:.04em; cursor:pointer; border-radius:6px; user-select:none; transition:background .15s; }
.nav-group-header:hover { background:#eaeef2; }
.nav-group-header::before { content:""; display:inline-block; width:0; height:0; border-left:5px solid var(--c2); border-top:3.5px solid transparent; border-bottom:3.5px solid transparent; transition:transform .2s; transform:rotate(90deg); flex-shrink:0; }
.nav-group.collapsed .nav-group-header::before { transform:rotate(0); }
.nav-group-children { list-style:none; margin:0 0 4px 19px; padding:3px 0 3px 13px; border-left:2px solid #e1e4e8; overflow:hidden; max-height:500px; transition:max-height .25s ease,opacity .2s ease,padding .2s ease; opacity:1; }
.nav-group.collapsed .nav-group-children { max-height:0; opacity:0; padding:0 0 0 13px; }
.nav-group-children li a { display:block; padding:4px 10px; font-size:13px; color:var(--c2); text-decoration:none; border-radius:4px; transition:background .15s,color .15s; }
.nav-group-children li a:hover { background:#e8e8e8; color:var(--c1); }
.nav-group-children li a.active { background:var(--nav-active); color:var(--accent); font-weight:600; }

.content { margin-left:var(--sidebar-w); max-width:900px; padding:40px 48px; }
article h1 { font-size:28px; font-weight:600; padding-bottom:10px; border-bottom:1px solid var(--border); margin-bottom:20px; }
article h2 { font-size:22px; font-weight:600; margin-top:32px; margin-bottom:12px; padding-bottom:6px; border-bottom:1px solid #eaecef; }
article h3 { font-size:18px; font-weight:600; margin-top:24px; margin-bottom:10px; }
article h4 { font-size:15px; font-weight:600; margin-top:20px; margin-bottom:8px; }
article p { margin-bottom:14px; }
article ul,article ol { margin-bottom:14px; padding-left:24px; }
article li { margin-bottom:4px; }
article a { color:var(--accent); text-decoration:none; }
article a:hover { text-decoration:underline; }
article code { background:var(--bg-code); padding:2px 6px; border-radius:4px; font-size:13px; font-family:"SFMono-Regular",Consolas,"Liberation Mono",Menlo,monospace; }
article pre { background:var(--bg-code); border:1px solid var(--border); border-radius:6px; padding:16px; overflow-x:auto; margin-bottom:16px; line-height:1.5; }
article pre code { background:none; padding:0; font-size:13px; }
article table { width:100%; border-collapse:collapse; margin-bottom:16px; font-size:14px; }
article th,article td { border:1px solid var(--border); padding:8px 12px; text-align:left; }
article th { background:var(--bg-code); font-weight:600; }
article tr:nth-child(even) { background:#f8f9fa; }
article hr { border:none; border-top:1px solid var(--border); margin:28px 0; }
article blockquote { border-left:4px solid var(--accent); padding:8px 16px; margin:0 0 16px; color:var(--c2); background:#f8f9fa; border-radius:0 6px 6px 0; }
article .mermaid { text-align:center; margin:20px 0; }
footer { margin-top:60px; padding-top:16px; border-top:1px solid var(--border); color:var(--c2); font-size:13px; }
@media(max-width:768px) {
  .sidebar { transform:translateX(-100%); }
  .sidebar.open { transform:translateX(0); box-shadow:2px 0 8px rgba(0,0,0,.15); }
  .sidebar-toggle { display:block; }
  .content { margin-left:0; padding:50px 20px 40px; }
  .content.shifted { margin-left:var(--sidebar-w); }
}
</style>
</head>
<body>
<button class="sidebar-toggle" onclick="toggleSidebar()" aria-label="Toggle sidebar">&#9776;</button>
<nav class="sidebar" id="sidebar">
  <div class="sidebar-header">
    <h2>MiniCPM-o 4.5</h2>
    <span class="sidebar-subtitle">项目文档</span>
    <a href="../../en/frontend/audio.html" class="lang-switch">English</a>
  </div>
  <ul class="nav-list">
    <li><a href="../index.html">项目概述</a></li>
    <li class="nav-group">
      <span class="nav-group-header">系统架构</span>
      <ul class="nav-group-children">
        <li><a href="../architecture/index.html">架构概述</a></li>
        <li><a href="../architecture/chat.html">Chat 模式</a></li>
        <li><a href="../architecture/half-duplex.html">Half-Duplex 模式</a></li>
        <li><a href="../architecture/duplex.html">Duplex 模式</a></li>
        <li><a href="../architecture/internals.html">内部机制</a></li>
      </ul>
    </li>
    <li><a href="../gateway.html">Gateway 模块</a></li>
    <li><a href="../worker.html">Worker 模块</a></li>
    <li><a href="../schema.html">Schema</a></li>
    <li><a href="../model.html">模型模块</a></li>
    <li><a href="../compile.html">torch.compile</a></li>
    <li class="nav-group">
      <span class="nav-group-header">前端模块</span>
      <ul class="nav-group-children">
        <li><a href="../frontend/index.html">前端概述</a></li>
        <li><a href="../frontend/pages.html">页面与路由</a></li>
        <li><a href="../frontend/audio.html" class="active">音频处理</a></li>
        <li><a href="../frontend/duplex-session.html">双工会话</a></li>
        <li><a href="../frontend/components.html">UI 组件</a></li>
      </ul>
    </li>
    <li><a href="../api.html">API 参考</a></li>
    <li><a href="../deployment.html">配置与部署</a></li>
  </ul>
</nav>
<main class="content" id="content">
  <article><h1 id="_1">前端音频处理架构</h1>
<h2 id="_2">架构总览</h2>
<pre class="mermaid">
graph TB
    subgraph capture [音频采集]
        MIC["麦克风\ngetUserMedia()"]
        CTX["AudioContext\n(16kHz)"]
        WL["AudioWorkletNode\ncapture-processor"]
        MIC --> CTX --> WL
    end

    subgraph transport [传输]
        WS["WebSocket\naudio_base64"]
    end

    subgraph playback [音频播放]
        AP["AudioPlayer"]
        RESAMP["重采样\n24kHz → 设备采样率"]
        BUF["AudioBufferSourceNode\n预调度播放"]
        AP --> RESAMP --> BUF
    end

    subgraph analysis [音频分析]
        LUFS["LUFS 测量\nITU-R BS.1770"]
        MIXER["MixerController\n自动增益"]
        LUFS --> MIXER
    end

    subgraph recording [录制]
        SREC["SessionRecorder\n立体声 WAV"]
        VREC["SessionVideoRecorder\n视频 + 音频"]
    end

    WL -->|"Float32 chunk (1s)"| WS
    WS -->|"Base64 audio (24kHz)"| AP
    AP --> SREC
    AP --> VREC
    BUF --> LUFS
</pre>

<hr />
<h2 id="capture-processorjs-audioworklet">capture-processor.js — AudioWorklet 音频采集</h2>
<p>运行在 Web Audio 渲染线程的 <code>AudioWorkletProcessor</code>，实现低延迟音频捕获。</p>
<h3 id="_3">工作原理</h3>
<div class="codehilite"><pre><span></span><code><span class="nx">process</span><span class="p">(</span><span class="nx">inputs</span><span class="p">,</span><span class="w"> </span><span class="nx">outputs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 1. 直通到输出（用于 MediaStreamDestination）</span>
<span class="w">    </span><span class="nx">output</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">input</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// 2. 累积到 _buffer</span>
<span class="w">    </span><span class="nx">_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">concat</span><span class="p">(</span><span class="nx">_buffer</span><span class="p">,</span><span class="w"> </span><span class="nx">input</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// 3. buffer 满一个 chunk 时发送</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="nx">_buffer</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="nx">_chunkSize</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">const</span><span class="w"> </span><span class="nx">chunk</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">_buffer</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">_chunkSize</span><span class="p">);</span>
<span class="w">        </span><span class="nx">_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">_buffer</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">_chunkSize</span><span class="p">);</span>
<span class="w">        </span><span class="nx">port</span><span class="p">.</span><span class="nx">postMessage</span><span class="p">({</span><span class="nx">type</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;chunk&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">audio</span><span class="o">:</span><span class="w"> </span><span class="nx">chunk</span><span class="p">},</span><span class="w"> </span><span class="p">[</span><span class="nx">chunk</span><span class="p">.</span><span class="nx">buffer</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="_4">配置</h3>
<table>
<thead>
<tr>
<th>参数</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>chunkSize</code></td>
<td>16000</td>
<td>每个 chunk 的样本数</td>
</tr>
<tr>
<td>采样率</td>
<td>16000 Hz</td>
<td>由 AudioContext <code>sampleRate</code> 决定</td>
</tr>
<tr>
<td>chunk 时长</td>
<td>1 秒</td>
<td>chunkSize / sampleRate</td>
</tr>
</tbody>
</table>
<h3 id="messageport">MessagePort 通信</h3>
<p><strong>接收命令</strong>：
- <code>{command: 'start'}</code> — 开始累积和发送 chunk
- <code>{command: 'stop'}</code> — 停止，发送剩余 buffer（<code>final: true</code>）</p>
<p><strong>发送消息</strong>：
- <code>{type: 'chunk', audio: Float32Array}</code> — 正常 chunk
- <code>{type: 'chunk', audio: Float32Array, final: true}</code> — 最后一个 chunk</p>
<p>使用 <code>Transferable</code> 对象（<code>[chunk.buffer]</code>）实现零拷贝传输。</p>
<hr />
<h2 id="audio-playerjs-ai">audio-player.js — AI 音频实时播放器</h2>
<p><code>AudioPlayer</code> 类管理从服务端接收的 AI 音频的实时无间隙播放。</p>
<h3 id="api">完整 API</h3>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>init()</code></td>
<td>初始化 AudioContext</td>
</tr>
<tr>
<td><code>beginTurn()</code></td>
<td>开始新的说话轮次（重置调度时间）</td>
</tr>
<tr>
<td><code>playChunk(base64Data, arrivalTime)</code></td>
<td>入队并调度一个音频 chunk</td>
</tr>
<tr>
<td><code>endTurn()</code></td>
<td>结束当前轮次</td>
</tr>
<tr>
<td><code>stopAll()</code></td>
<td>立即停止所有播放（强制监听时使用）</td>
</tr>
<tr>
<td><code>stop()</code></td>
<td>完整停止并清理</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>turnActive</code></td>
<td>是否处于说话轮次</td>
</tr>
<tr>
<td><code>playing</code></td>
<td>是否正在播放</td>
</tr>
<tr>
<td><code>gapCount</code></td>
<td>间隙总数</td>
</tr>
<tr>
<td><code>totalShiftMs</code></td>
<td>总漂移时间</td>
</tr>
<tr>
<td><code>lastAheadMs</code></td>
<td>最后的前置缓冲时间</td>
</tr>
</tbody>
</table>
<h3 id="_5">播放流程</h3>
<pre class="mermaid">
sequenceDiagram
    participant S as 服务端
    participant AP as AudioPlayer
    participant ACX as AudioContext

    S->>AP: playChunk(base64)
    AP->>AP: Base64 → Float32Array
    AP->>AP: 重采样 24kHz → 设备采样率
    AP->>AP: 创建 AudioBuffer

    alt 首个 chunk + 配置了延迟
        AP->>AP: setTimeout(playbackDelay)
        Note over AP: 等待更多 chunk 到达避免间隙
    end

    AP->>ACX: bufferSource.start(nextTime)
    AP->>AP: nextTime += buffer.duration

    Note over AP: 后续 chunk 紧密拼接
    S->>AP: playChunk(base64)
    AP->>ACX: bufferSource.start(nextTime)
</pre>

<h3 id="_6">间隙检测</h3>
<p>当 <code>nextTime &lt; AudioContext.currentTime</code> 时检测到间隙（buffer underrun）：</p>
<div class="codehilite"><pre><span></span><code>gapMs = (currentTime - nextTime) * 1000
if gapMs &gt; 10ms:
    gapCount++
    totalShiftMs += gapMs
    nextTime = currentTime + 小偏移    // 修正
    触发 onGap 回调
</code></pre></div>

<p>间隙通常由网络延迟或推理速度慢导致。</p>
<h3 id="_7">播放延迟</h3>
<p>通过 <code>getPlaybackDelayMs()</code> 配置（默认 200ms，对应 <code>config.json</code> 中的 <code>playback_delay_ms</code>）。</p>
<ul>
<li>延迟越大 → 缓冲越多 → 播放越平滑，但首音延迟越高</li>
<li>延迟为 0 → 收到即播放，可能有间隙</li>
</ul>
<h3 id="_8">回调</h3>
<ul>
<li><code>onMetrics(data)</code> — 指标上报：<code>{ahead, gapCount, totalShift, turn, pdelay}</code></li>
<li><code>onGap(info)</code> — 间隙事件：<code>{gap_idx, gap_ms, total_shift_ms, chunk_idx, turn}</code></li>
<li><code>onRawAudio(samples, sampleRate, timestamp)</code> — 原始音频数据（供 SessionRecorder 使用）</li>
</ul>
<hr />
<h2 id="lufsjs-lufs">lufs.js — LUFS 响度测量</h2>
<p>实现 <strong>ITU-R BS.1770</strong> 集成响度测量算法。</p>
<h3 id="_9">算法步骤</h3>
<ol>
<li><strong>K 加权滤波</strong>：两级 IIR 滤波器（高通 + 高频增益），模拟人耳频率感知</li>
<li><strong>分块均方值</strong>：将信号分为 400ms 重叠块，计算每块的均方值</li>
<li><strong>绝对门限</strong>：去除低于 -70 LUFS 的静音块</li>
<li><strong>相对门限</strong>：计算剩余块的平均值，去除低于平均值 -10 dB 的块</li>
<li><strong>集成响度</strong>：计算最终块的加权平均 → LUFS 值</li>
</ol>
<h3 id="_10">用途</h3>
<ul>
<li><code>MixerController</code> 用于实时音频电平监控</li>
<li><code>FileAudioProvider</code> 用于音频文件归一化（调整增益使响度一致）</li>
</ul>
<hr />
<h2 id="mixer-controllerjs">mixer-controller.js — 混音器控制</h2>
<p><code>MixerController</code> 提供双通道音频混音控制界面。</p>
<h3 id="_11">功能</h3>
<table>
<thead>
<tr>
<th>功能</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>实时 LUFS 计量</td>
<td>分别显示用户和 AI 音频的实时响度</td>
</tr>
<tr>
<td>自动增益</td>
<td>基于 LUFS 自动调整 AI 音频音量</td>
</tr>
<tr>
<td>独立音量控制</td>
<td>用户/AI 音量滑块独立调节</td>
</tr>
<tr>
<td>可拖动面板</td>
<td>浮动面板 UI，可拖拽到任意位置</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="duplex-utilsjs">duplex-utils.js — 工具函数</h2>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>resampleAudio(input, srcRate, dstRate)</code></td>
<td>线性插值重采样</td>
</tr>
<tr>
<td><code>float32ToBase64(float32Array)</code></td>
<td>Float32 数组 → Base64 字符串</td>
</tr>
<tr>
<td><code>base64ToFloat32(base64)</code></td>
<td>Base64 字符串 → Float32 数组</td>
</tr>
</tbody>
</table>
<p>重采样逻辑：计算采样率比值，按线性插值对每个目标样本点取两个最近源样本点的加权平均。</p>
<hr />
<h2 id="stereo-recorder-processorjs">stereo-recorder-processor.js — 立体声处理器</h2>
<p><code>AudioWorkletProcessor</code> 实现，用于 <code>SessionRecorder</code> 的立体声录制：
- 接收两路音频输入（用户 + AI）
- 交织为立体声帧（左 = 用户，右 = AI）
- 通过 MessagePort 发送立体声 PCM 数据</p>
<hr />
<h2 id="queue-chimesjs">queue-chimes.js — 排队音效</h2>
<p>使用 Web Audio API 合成排队状态音效：
- 入队时：低音提示
- 排队完成时：高音提示
- 纯合成音，无外部音频文件依赖</p></article>
  <footer><p>MiniCPM-o 4.5 PyTorch Simple Demo &mdash; 由 build_docs.py 自动生成</p></footer>
</main>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/bash.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/json.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script>
<script type="module">
import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
mermaid.initialize({startOnLoad:true,theme:'default',securityLevel:'loose'});
</script>
<script>
hljs.highlightAll();
function toggleSidebar(){document.getElementById('sidebar').classList.toggle('open');document.getElementById('content').classList.toggle('shifted');}
document.querySelectorAll('.nav-group-header').forEach(function(h){h.addEventListener('click',function(){this.parentElement.classList.toggle('collapsed');});});
document.addEventListener('click',function(e){var s=document.getElementById('sidebar'),t=document.querySelector('.sidebar-toggle');if(window.innerWidth<=768&&s.classList.contains('open')&&!s.contains(e.target)&&!t.contains(e.target)){s.classList.remove('open');document.getElementById('content').classList.remove('shifted');}});
</script>
</body>
</html>
