<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MiniCPMO45 Turn-based Chat</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        [data-tooltip] { position: relative; cursor: help; }
        [data-tooltip]::after {
            content: attr(data-tooltip); position: absolute; bottom: calc(100% + 6px); left: 50%;
            transform: translateX(-50%); background: rgba(0,0,0,0.85); color: #fff;
            padding: 8px 12px; border-radius: 6px; font-size: 12px; line-height: 1.5;
            white-space: normal; width: max-content; max-width: 280px;
            pointer-events: none; opacity: 0; transition: opacity 0.15s ease;
            transition-delay: 0s; z-index: 1000;
        }
        [data-tooltip]:hover::after { opacity: 1; transition-delay: 0.2s; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'PingFang SC', 'Noto Sans SC', sans-serif;
            background: #f5f5f0;
            color: #2d2d2d;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* é¡¶éƒ¨å¯¼èˆª */
        .header {
            background: #fff;
            padding: 12px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #e5e5e0;
        }
        .header h1 { font-size: 16px; font-weight: 600; color: #2d2d2d; letter-spacing: -0.3px; }
        .header .status {
            font-size: 12px;
            padding: 3px 10px;
            border-radius: 10px;
            background: #f0f0eb;
            color: #666;
        }
        .header .status.online { color: #1a7f37; background: #ddf4e4; }
        .header .status.offline { color: #cf222e; background: #ffe3e6; }
        .nav-links { display: flex; gap: 6px; }
        .nav-links a {
            font-size: 13px; padding: 4px 12px; border-radius: 6px;
            text-decoration: none; transition: all 0.15s;
        }
        .nav-links a.active { background: #2d2d2d; color: #fff; }
        .nav-links a:not(.active) { color: #666; }
        .nav-links a:not(.active):hover { background: #f0f0eb; }

        /* ================ åˆå§‹è§†å›¾ï¼ˆChatGPT é£æ ¼ï¼‰ ================ */
        .initial-view {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px 20px;
            gap: 32px;
        }
        .initial-view.hidden { display: none; }

        .initial-title {
            font-size: 24px;
            font-weight: 600;
            color: #2d2d2d;
        }
        .initial-subtitle {
            font-size: 14px;
            color: #999;
            margin-top: -20px;
        }

        /* System é…ç½®å¡ç‰‡ */
        .system-config-card {
            background: #fff;
            border: 1px solid #e5e5e0;
            border-radius: 16px;
            padding: 20px;
            width: 100%;
            max-width: 640px;
        }
        .system-config-card summary {
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            color: #666;
            user-select: none;
            list-style: none;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .system-config-card summary::-webkit-details-marker { display: none; }
        .system-config-card summary::before { content: 'â–¸'; transition: transform 0.15s; }
        .system-config-card[open] summary::before { transform: rotate(90deg); }
        .system-config-card .sc-body {
            margin-top: 12px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .sc-field label {
            display: block;
            font-size: 12px;
            color: #999;
            margin-bottom: 4px;
        }
        /* TTS Ref Audio æ§ä»¶ */
        .tts-ref-wrap {
            padding: 8px 10px;
            background: #fafaf8;
            border: 1px solid #e8e6e0;
            border-radius: 8px;
            font-size: 12px;
        }
        .tts-ref-wrap .tts-ref-header {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 6px;
            color: #666;
            font-weight: 500;
        }
        .tts-ref-wrap .tts-ref-options {
            display: flex;
            gap: 12px;
            align-items: center;
            margin-bottom: 4px;
        }
        .tts-ref-wrap .tts-ref-options label {
            display: inline;
            margin-bottom: 0;
            cursor: pointer;
            color: #555;
        }
        .tts-ref-wrap .tts-ref-hint {
            font-size: 11px;
            color: #aaa;
            margin-top: 2px;
        }
        .tts-ref-wrap .tts-ref-hint.warning { color: #d4a017; }
        .tts-ref-wrap .tts-ref-upload { margin-top: 6px; }
        .sc-field textarea {
            width: 100%;
            border: 1px solid #e5e5e0;
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 13px;
            resize: vertical;
            outline: none;
            font-family: inherit;
            min-height: 60px;
            transition: border-color 0.15s;
        }
        .sc-field textarea:focus { border-color: #999; }
        .sc-field textarea::placeholder { color: #ccc; }

        /* åˆå§‹è¾“å…¥æ¡† */
        .initial-input-wrap {
            width: 100%;
            max-width: 640px;
            background: #fff;
            border: 1px solid #d5d5d0;
            border-radius: 16px;
            padding: 4px;
            transition: border-color 0.15s;
        }
        .initial-input-wrap:focus-within { border-color: #999; }
        /* UCE ç©ºçŠ¶æ€çš„ textarea ç»§æ‰¿å¤–å±‚å®¹å™¨æ ·å¼ */
        .initial-input-wrap .uce-empty-ta {
            min-height: 40px;
            max-height: 180px;
        }
        .initial-input-wrap .uce-empty-ta::placeholder { color: #bbb; }

        /* ================ å¯¹è¯è§†å›¾ ================ */
        .chat-view {
            flex: 1;
            display: flex;
            flex-direction: column;
            max-width: 960px;
            width: 100%;
            margin: 0 auto;
            padding: 0 16px;
            overflow: hidden;
        }
        .chat-view.hidden { display: none; }

        /* System é…ç½®æ¡ï¼ˆå¯¹è¯ä¸­çš„æŠ˜å ç‰ˆæœ¬ï¼‰ */
        .sys-config-bar {
            background: #fff;
            border: 1px solid #e5e5e0;
            border-radius: 10px;
            margin: 8px 0;
            font-size: 12px;
            overflow: hidden;
        }
        .sys-config-bar summary {
            cursor: pointer;
            padding: 6px 12px;
            color: #888;
            user-select: none;
            list-style: none;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .sys-config-bar summary::-webkit-details-marker { display: none; }
        .sys-config-bar summary::before { content: 'âš™'; }
        .sys-config-bar .sc-inline-body {
            padding: 0 12px 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        /* æ¶ˆæ¯åˆ—è¡¨ */
        .messages {
            flex: 1;
            overflow-y: auto;
            padding: 8px 0 16px;
        }
        .message {
            margin-bottom: 20px;
            display: flex;
            gap: 12px;
            position: relative;
        }
        .message .avatar {
            width: 28px; height: 28px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            flex-shrink: 0;
            margin-top: 2px;
        }
        .message.user .avatar { background: #e8e8e3; }
        .message.assistant .avatar { background: #d4a574; color: #fff; font-size: 12px; }

        .message .msg-body {
            max-width: 85%;
            min-width: 0;
            flex: 1;
        }
        .message .content {
            padding: 0;
            line-height: 1.65;
            white-space: pre-wrap;
            word-break: break-word;
            font-size: 14.5px;
            color: #2d2d2d;
        }
        .message.user .content {
            background: #fff;
            border: 1px solid #e5e5e0;
            border-radius: 12px;
            padding: 10px 14px;
            color: #2d2d2d;
        }
        .message .meta {
            font-size: 11px;
            color: #999;
            margin-top: 6px;
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        .meta-line {
            display: flex;
            align-items: center;
            gap: 6px;
            flex-wrap: wrap;
        }
        .meta-label { color: #bbb; }
        .meta-value { color: #888; font-family: 'SF Mono', 'Menlo', monospace; font-size: 10.5px; }
        .meta-sep { color: #ddd; }
        .meta-rid {
            font-family: 'SF Mono', 'Menlo', monospace;
            font-size: 10px;
            color: #aaa;
            background: #f5f5f0;
            padding: 1px 6px;
            border-radius: 3px;
            cursor: pointer;
            user-select: none;
            transition: all 0.15s;
            border: 1px solid transparent;
        }
        .meta-rid:hover { color: #666; background: #eee; border-color: #ddd; }
        .meta-rid.copied { color: #1a7f37; background: #ddf4e4; }
        /* éå¯¹è¯å†…å®¹ï¼šAPP çº§ç³»ç»Ÿæ—¥å¿—æ¶ˆæ¯ï¼ˆæ’é˜Ÿã€é”™è¯¯ç­‰ï¼‰ */
        .message .content.is-system-log {
            border-radius: 8px;
            padding: 10px 14px;
            font-size: 13px;
            background: #fffbeb;
            border: 1px solid #fde68a;
            color: #92400e;
        }
        .message .content.is-system-log.is-error {
            background: #fff5f5;
            border-color: #fcd4d4;
            color: #9a2020;
        }

        /* æ¶ˆæ¯ç¼–è¾‘ */
        .msg-edit-btn {
            position: absolute;
            right: 0;
            top: 2px;
            font-size: 11px;
            color: #bbb;
            cursor: pointer;
            padding: 2px 6px;
            border-radius: 4px;
            opacity: 0;
            transition: opacity 0.15s;
        }
        .message:hover .msg-edit-btn { opacity: 1; }
        .msg-edit-btn:hover { color: #666; background: #f0f0eb; }
        .msg-edit-area {
            width: 100%;
            border: 1px solid #d4a574;
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 14px;
            font-family: inherit;
            resize: vertical;
            outline: none;
            min-height: 60px;
        }
        /* User æ¶ˆæ¯æ“ä½œæ ï¼ˆå¸¸é©»ã€ç«–æ’ã€flex å­å…ƒç´ é¿å… overflow è£å‰ªï¼‰ */
        .msg-actions-col {
            display: flex;
            flex-direction: column;
            gap: 4px;
            flex-shrink: 0;
            align-self: flex-start;
            margin-top: 2px;
        }
        .msg-actions-col .msg-action-btn {
            width: 26px; height: 26px;
            display: flex; align-items: center; justify-content: center;
            border: none;
            border-radius: 6px;
            background: transparent;
            color: #ccc;
            cursor: pointer;
            transition: all 0.12s;
            padding: 0;
        }
        .msg-actions-col .msg-action-btn svg {
            width: 14px; height: 14px;
        }
        .msg-actions-col .msg-action-btn:hover { color: #888; background: #f0f0eb; }
        .msg-actions-col .msg-action-btn.resend-btn:hover { color: #d4a574; background: #faf5ef; }
        .msg-actions-col .msg-action-btn:disabled { opacity: 0.25; cursor: default; pointer-events: none; }

        /* å†…å®¹åˆ—è¡¨è§†å›¾æ¨¡å¼ */
        .msg-content-items .msg-ci-text {
            margin-bottom: 2px;
        }
        .msg-content-items .msg-ci-audio {
            margin: 4px 0;
        }
        .msg-content-items .msg-ci-image {
            margin: 4px 0;
        }
        .msg-content-items .msg-ci-image img {
            max-width: 240px;
            max-height: 200px;
            border-radius: 8px;
            border: 1px solid #e5e5e0;
            cursor: pointer;
            transition: opacity 0.15s;
        }
        .msg-content-items .msg-ci-image img:hover { opacity: 0.85; }

        /* ç¼–è¾‘å™¨å®¹å™¨ */
        .msg-edit-editor-wrap {
            margin-bottom: 4px;
        }

        /* éŸ³é¢‘æ§ä»¶ */
        .audio-ctrl {
            margin-top: 10px;
            background: #fff;
            border: 1px solid #e5e5e0;
            border-radius: 8px;
            padding: 6px 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            user-select: none;
            font-size: 12px;
        }
        .audio-ctrl button {
            width: 24px; height: 24px;
            border-radius: 50%;
            border: none;
            color: white;
            cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            flex-shrink: 0;
            font-size: 10px;
            transition: opacity 0.15s;
        }
        .audio-ctrl button:hover { opacity: 0.75; }
        .audio-ctrl .ac-play { background: #2d2d2d; }
        .audio-ctrl .ac-time {
            color: #999;
            white-space: nowrap;
            min-width: 68px;
            font-variant-numeric: tabular-nums;
            font-size: 11px;
        }
        .audio-ctrl .ac-bar {
            flex: 1;
            height: 3px;
            background: #e5e5e0;
            border-radius: 2px;
            position: relative;
            cursor: pointer;
            min-width: 60px;
        }
        .audio-ctrl .ac-bar-fill {
            position: absolute; top: 0; left: 0;
            height: 100%;
            background: #2d2d2d;
            border-radius: 2px;
            pointer-events: none;
        }
        .audio-ctrl .ac-bar-dot {
            position: absolute; top: -4px;
            width: 11px; height: 11px;
            background: #2d2d2d;
            border: 2px solid #fff;
            border-radius: 50%;
            transform: translateX(-50%);
            box-shadow: 0 0 2px rgba(0,0,0,0.15);
            pointer-events: none;
        }

        /* è¾“å…¥åŒº */
        .input-area {
            padding: 0 0 20px;
        }
        .input-wrap {
            background: #fff;
            border: 1px solid #d5d5d0;
            border-radius: 16px;
            padding: 4px;
            transition: border-color 0.15s;
        }
        .input-wrap:focus-within { border-color: #999; }

        /* UCE ç©ºçŠ¶æ€çš„ textarea ç»§æ‰¿å¤–å±‚å®¹å™¨æ ·å¼ */
        .input-wrap .uce-empty-ta {
            min-height: 40px;
            max-height: 180px;
        }
        .input-wrap .uce-empty-ta::placeholder { color: #bbb; }

        .input-bottom {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 2px 6px 4px 10px;
        }

        .input-options {
            display: flex;
            gap: 10px;
            align-items: center;
            font-size: 12px;
            color: #999;
        }
        .input-options select, .input-options input[type="number"] {
            background: #f5f5f0;
            border: 1px solid #e5e5e0;
            border-radius: 6px;
            padding: 2px 6px;
            color: #555;
            font-size: 11px;
            outline: none;
        }
        .input-options label { color: #999; font-size: 11px; }
        .input-options .opt-group {
            display: flex;
            align-items: center;
            gap: 3px;
        }
        .input-options input[type="checkbox"] {
            accent-color: #d4a574;
        }

        .btn-send {
            width: 32px; height: 32px;
            border-radius: 10px;
            border: none;
            background: #2d2d2d;
            color: white;
            cursor: pointer;
            font-size: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.15s;
            flex-shrink: 0;
        }
        .btn-send:hover { background: #444; }
        .btn-send:disabled { background: #ddd; color: #aaa; cursor: not-allowed; }

        /* å½•éŸ³æŒ‰é’®ï¼ˆå¤§å·ï¼Œç‹¬ç«‹é†’ç›®ï¼‰ */
        .btn-record {
            width: 44px; height: 44px;
            border-radius: 50%;
            border: 2px solid #d5d5d0;
            background: #fff;
            color: #888;
            cursor: pointer;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
            flex-shrink: 0;
            position: relative;
        }
        .btn-record:hover { border-color: #999; color: #555; background: #f8f8f5; }
        .btn-record.recording {
            border-color: #cf222e;
            background: #cf222e;
            color: #fff;
            animation: record-pulse 1s infinite;
        }
        @keyframes record-pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(207, 34, 46, 0.3); }
            50% { box-shadow: 0 0 0 8px rgba(207, 34, 46, 0); }
        }
        .record-timer {
            position: absolute;
            bottom: -18px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: #cf222e;
            font-weight: 600;
            white-space: nowrap;
            font-variant-numeric: tabular-nums;
        }
        .record-hint {
            font-size: 10px;
            color: #bbb;
            text-align: center;
            margin-top: 2px;
            white-space: nowrap;
            letter-spacing: -0.2px;
        }

        /* éŸ³é¢‘è¾“å…¥æŒ‰é’®ï¼ˆå°å·ï¼‰ */
        .input-actions {
            display: flex;
            gap: 4px;
            align-items: center;
        }
        .input-actions button {
            width: 32px; height: 32px;
            border-radius: 10px;
            border: 1px solid #d5d5d0;
            background: #fff;
            color: #888;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
        }
        .input-actions button:hover { border-color: #999; color: #555; }
        .input-actions button.recording {
            border-color: #cf222e;
            color: #cf222e;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .input-actions input[type="file"] { display: none; }

        /* Mic / Attach action buttons */
        .input-actions .btn-mic {
            width: auto;
            padding: 0 10px;
            gap: 4px;
        }
        .input-actions .btn-mic .kbd-hint {
            font-size: 9px;
            opacity: 0.5;
            font-weight: 600;
            letter-spacing: 0.3px;
        }
        .input-actions .btn-mic:hover {
            border-color: #cf222e;
            color: #cf222e;
            background: #fff5f5;
        }
        .input-actions .btn-attach:hover {
            border-color: #4070a0;
            color: #4070a0;
            background: #f5f8fb;
        }

        /* Drag & drop overlay */
        .initial-input-wrap, .input-wrap { position: relative; }
        .drag-overlay {
            display: none;
            position: absolute;
            inset: 0;
            background: rgba(64, 112, 160, 0.06);
            border: 2px dashed #4070a0;
            border-radius: 14px;
            z-index: 10;
            pointer-events: none;
            align-items: center;
            justify-content: center;
            gap: 8px;
            color: #4070a0;
            font-size: 13px;
            font-weight: 500;
        }
        .drag-overlay.visible { display: flex; }

        /* é™„ä»¶é¢„è§ˆ */
        .attachments {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            padding: 4px 10px 2px;
        }
        .attachment {
            display: flex;
            align-items: center;
            gap: 4px;
            background: #f0f0eb;
            border-radius: 6px;
            padding: 3px 8px;
            font-size: 11px;
            color: #555;
        }
        .attachment .att-remove {
            cursor: pointer;
            color: #999;
            font-size: 13px;
            line-height: 1;
        }
        .attachment .att-remove:hover { color: #cf222e; }

        /* è¿·ä½ éŸ³é¢‘æ’­æ”¾å™¨ */
        .mini-player {
            margin-top: 8px;
            background: #fff;
            border: 1px solid #e5e5e0;
            border-radius: 8px;
            padding: 6px 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            user-select: none;
            font-size: 12px;
        }
        .mini-player .mp-btn {
            width: 24px; height: 24px;
            border-radius: 50%;
            border: none;
            background: #2d2d2d;
            color: #fff;
            font-size: 10px;
            cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            flex-shrink: 0;
            transition: opacity 0.15s;
        }
        .mini-player .mp-btn:hover { opacity: 0.75; }
        .mini-player .mp-bar {
            flex: 1;
            height: 3px;
            background: #e5e5e0;
            border-radius: 2px;
            position: relative;
            cursor: pointer;
            min-width: 60px;
        }
        .mini-player .mp-bar-fill {
            position: absolute; top: 0; left: 0;
            height: 100%; background: #2d2d2d;
            border-radius: 2px;
            pointer-events: none;
        }
        .mini-player .mp-bar-dot {
            position: absolute; top: -4px;
            width: 11px; height: 11px;
            background: #2d2d2d;
            border: 2px solid #fff;
            border-radius: 50%;
            transform: translateX(-50%);
            box-shadow: 0 0 2px rgba(0,0,0,0.15);
            pointer-events: none;
        }
        .mini-player .mp-time {
            color: #999;
            white-space: nowrap;
            min-width: 40px;
            font-variant-numeric: tabular-nums;
            font-size: 11px;
        }

        /* ä¸‹è½½æŒ‰é’®ï¼ˆéŸ³é¢‘/å›¾ç‰‡æ¡ç›®å³ä¾§ï¼‰ */
        .dl-btn {
            width: 22px; height: 22px;
            border: none; background: none;
            cursor: pointer;
            color: #999;
            display: inline-flex; align-items: center; justify-content: center;
            flex-shrink: 0;
            border-radius: 4px;
            transition: color 0.15s, background 0.15s;
            padding: 0;
        }
        .dl-btn:hover { color: #2d2d2d; background: rgba(0,0,0,0.06); }
        .dl-btn svg { width: 14px; height: 14px; }
        .msg-ci-audio, .msg-ci-image { position: relative; }
        .msg-ci-audio .dl-btn, .msg-ci-image .dl-btn {
            position: absolute; top: 4px; right: 4px;
            opacity: 0; transition: opacity 0.15s;
        }
        .msg-ci-audio:hover .dl-btn, .msg-ci-image:hover .dl-btn { opacity: 1; }

        /* Export æŒ‰é’®ï¼ˆå¯¹è¯å·¥å…·æ ï¼‰ */
        .chat-toolbar {
            display: flex; justify-content: flex-end; padding: 0 4px 4px; gap: 6px;
        }
        .chat-toolbar .btn-export {
            font-size: 12px; padding: 3px 10px;
            border: 1px solid #d5d5d0; border-radius: 6px;
            background: #fff; color: #666; cursor: help;
            display: flex; align-items: center; gap: 4px;
            transition: background 0.15s, color 0.15s;
        }
        .chat-toolbar .btn-export:hover { background: #f5f5f0; color: #333; }
        .chat-toolbar .btn-export:active { cursor: pointer; }
        .chat-toolbar .btn-export svg { width: 13px; height: 13px; }

        /* JS-positioned tooltip (follows cursor, never clipped by viewport) */
        .data-tip-popup {
            position: fixed; z-index: 10000;
            padding: 8px 12px; border-radius: 6px;
            background: rgba(0,0,0,0.85); color: #fff;
            font-size: 12px; font-weight: 400; line-height: 1.5;
            white-space: normal; max-width: 340px;
            pointer-events: none;
        }

        /* æ‰“å­—æŒ‡ç¤ºå™¨ */
        .typing-indicator {
            display: none;
            color: #999;
            font-size: 13px;
            padding: 4px 0;
            align-items: center;
            gap: 8px;
        }
        .typing-indicator.active { display: flex; }
        .btn-stop {
            padding: 3px 12px;
            border: 1px solid #d5d5d0;
            border-radius: 6px;
            background: #fff;
            color: #888;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.15s;
        }
        .btn-stop:hover { border-color: #cf222e; color: #cf222e; background: #fff5f5; }

        /* æ»šåŠ¨æ¡ */
        ::-webkit-scrollbar { width: 5px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #d5d5d0; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #bbb; }
    </style>
</head>
<body>
    <!-- ========== Header ========== -->
    <div class="header">
        <div style="display:flex;align-items:center;gap:16px;">
            <h1>MiniCPM-o 4.5</h1>
            <div class="nav-links">
                <a href="/">Home</a>
                <a href="/turnbased" class="active">Turn-based Chat</a>
                <a href="/omni">Omni Full-Duplex</a>
                <a href="/audio_duplex">Audio Full-Duplex</a>
            </div>
        </div>
        <div class="status" id="serviceStatus">connecting...</div>
    </div>

    <!-- ========== åˆå§‹è§†å›¾ï¼ˆChatGPT é£æ ¼ï¼‰ ========== -->
    <div class="initial-view" id="initialView">
        <div class="initial-title">MiniCPM-o 4.5</div>
        <div class="initial-subtitle">Text Â· Image Â· Audio â€” Multimodal Chat</div>

        <!-- System é…ç½® -->
        <details class="system-config-card" id="systemConfigCard">
            <summary>System Settings (optional)</summary>
            <div class="sc-body">
                <div class="sc-field">
                    <label>System Content (text + audio, reorderable)</label>
                    <div id="sysContentEditorInit"></div>
                </div>
                <div class="sc-field">
                    <div class="tts-ref-wrap" id="ttsRefWrapInit">
                        <div class="tts-ref-header">TTS Ref Audio (voice cloning)</div>
                        <div class="tts-ref-options">
                            <label><input type="radio" name="ttsRefModeInit" value="extract" checked onchange="onTtsRefModeChange()"> Extract from System</label>
                            <label><input type="radio" name="ttsRefModeInit" value="independent" onchange="onTtsRefModeChange()"> Independent</label>
                        </div>
                        <div class="tts-ref-hint" id="ttsRefHintInit"></div>
                        <div class="tts-ref-upload" id="ttsRefUploadInit" style="display:none;"></div>
                    </div>
                </div>
            </div>
        </details>

        <!-- é¦–è½®è¾“å…¥ï¼ˆUserContentEditorï¼‰ -->
        <div class="initial-input-wrap">
            <div class="drag-overlay" id="dragOverlayInit">ğŸ“ Drop image or audio here</div>
            <div id="composeEditorInit"></div>
            <div class="input-bottom">
                <div class="input-options">
                    <div class="opt-group">
                        <select id="modeSelectInit">
                            <option value="chat">Chat</option>
                            <option value="streaming" selected>Streaming</option>
                        </select>
                    </div>
                    <div class="opt-group">
                        <label>tokens</label>
                        <input type="number" id="maxTokensInit" value="256" min="1" max="2048" style="width:52px">
                    </div>
                    <div class="opt-group">
                        <label data-tooltip="Higher value = longer AI responses. EOS logit (tts_eos, im_end, eos) is divided by this value, making it harder to stop. Values slightly above 1.0 have significant effect.">len_pen</label>
                        <input type="number" id="lengthPenaltyInit" value="1.1" min="0.1" max="5.0" step="0.05" style="width:52px" data-tooltip="Higher value = longer AI responses. EOS logit divided by this value.">
                    </div>
                    <div class="opt-group">
                        <input type="checkbox" id="enableTtsInit" checked>
                        <label for="enableTtsInit">TTS</label>
                    </div>
                    <div class="opt-group">
                        <input type="checkbox" id="enableHDInit" checked>
                        <label for="enableHDInit" data-tooltip="HD vision: 1 source + 2 slices = 192 tok/image. Better for text/details in images.">HD</label>
                    </div>
                </div>
                <div class="input-actions">
                    <button class="btn-mic" id="micBtnInit" title="Record audio (Space key)">ğŸ¤ <span class="kbd-hint">Space</span></button>
                    <button class="btn-attach" id="attachBtnInit" title="Attach image or audio (drag &amp; drop / paste also supported)">ğŸ“</button>
                    <button class="btn-send" id="sendBtnInit" onclick="sendFirstMessage()">&#8593;</button>
                </div>
            </div>
        </div>
    </div>

    <!-- ========== å¯¹è¯è§†å›¾ ========== -->
    <div class="chat-view hidden" id="chatView">
        <!-- System é…ç½®æŠ˜å æ¡ -->
        <details class="sys-config-bar" id="sysConfigBar">
            <summary id="sysConfigBarSummary">System Settings</summary>
            <div class="sc-inline-body">
                <div class="sc-field">
                    <label>System Content</label>
                    <div id="sysContentEditorChat"></div>
                </div>
                <div class="sc-field">
                    <div class="tts-ref-wrap" id="ttsRefWrapChat">
                        <div class="tts-ref-header">TTS Ref Audio</div>
                        <div class="tts-ref-options">
                            <label><input type="radio" name="ttsRefModeChat" value="extract" checked onchange="onTtsRefModeChange()"> Extract from System</label>
                            <label><input type="radio" name="ttsRefModeChat" value="independent" onchange="onTtsRefModeChange()"> Independent</label>
                        </div>
                        <div class="tts-ref-hint" id="ttsRefHintChat"></div>
                        <div class="tts-ref-upload" id="ttsRefUploadChat" style="display:none;"></div>
                    </div>
                </div>
            </div>
        </details>

        <div class="chat-toolbar">
            <button class="btn-export" onclick="exportConversation()" data-tip="Export conversation as .msgpack â€” MessagePack is a JSON-like binary format that can store raw bytes (audio, images). Open .msgpack files in Cursor/VS Code with the msgpack-audio-viewer extension. You can also read .msgpack programmatically with any msgpack library (Python, JS, etc.).">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                Export .msgpack
            </button>
        </div>

        <div class="messages" id="messages"></div>

        <div class="typing-indicator" id="typingIndicator">
            <span>Generating...</span>
            <button class="btn-stop" id="btnCancelStop" onclick="cancelGeneration()">âœ• Cancel</button>
        </div>

        <div class="input-area">
            <div class="input-wrap">
                <div class="drag-overlay" id="dragOverlayChat">ğŸ“ Drop image or audio here</div>
                <div id="composeEditorChat"></div>
                <div class="input-bottom">
                    <div class="input-options">
                        <div class="opt-group">
                            <select id="modeSelect">
                                <option value="chat">Chat</option>
                                <option value="streaming" selected>Streaming</option>
                            </select>
                        </div>
                        <div class="opt-group">
                            <label>tokens</label>
                            <input type="number" id="maxTokens" value="256" min="1" max="2048" style="width:52px">
                        </div>
                        <div class="opt-group">
                            <label data-tooltip="Higher value = longer AI responses. EOS logit (tts_eos, im_end, eos) is divided by this value, making it harder to stop. Values slightly above 1.0 have significant effect.">len_pen</label>
                            <input type="number" id="lengthPenalty" value="1.1" min="0.1" max="5.0" step="0.05" style="width:52px" data-tooltip="Higher value = longer AI responses. EOS logit divided by this value.">
                        </div>
                        <div class="opt-group">
                            <input type="checkbox" id="enableTts" checked>
                            <label for="enableTts">TTS</label>
                        </div>
                        <div class="opt-group">
                            <input type="checkbox" id="enableHD" checked>
                            <label for="enableHD" data-tooltip="HD vision: 1 source + 2 slices = 192 tok/image. Better for text/details in images.">HD</label>
                        </div>
                        <div class="opt-group" id="maxKvGroup" style="display:none;">
                            <label data-tooltip="Max KV cache tokens for the session. When exceeded, a warning is shown. Default 8192 (8k).">max_kv</label>
                            <input type="number" id="maxKvTokens" value="8192" min="512" max="131072" step="512" style="width:60px"
                                   data-tooltip="Max KV cache tokens. Warning shown when exceeded.">
                        </div>
                    </div>
                    <div class="input-actions">
                        <button class="btn-mic" id="micBtnChat" title="Record audio (Space key)">ğŸ¤ <span class="kbd-hint">Space</span></button>
                        <button class="btn-attach" id="attachBtnChat" title="Attach image or audio (drag &amp; drop / paste also supported)">ğŸ“</button>
                        <button class="btn-send" id="sendBtn" onclick="sendMessage()">&#8593;</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

<script src="/static/ref-audio-player.js"></script>
<script src="/static/system-content-editor.js"></script>
<script src="/static/user-content-editor.js"></script>
<script>
// ============ çŠ¶æ€ ============
// é»˜è®¤ system content listï¼ˆæ¨¡å‹æœ€ä½³å®è·µï¼štext + ref_audio + textï¼‰
const DEFAULT_SYSTEM_CONTENT = [
    { type: 'text', text: 'æ¨¡ä»¿éŸ³é¢‘æ ·æœ¬çš„éŸ³è‰²å¹¶ç”Ÿæˆæ–°çš„å†…å®¹ã€‚' },
    { type: 'audio', data: null, name: '', duration: 0 },
    { type: 'text', text: 'ä½ çš„ä»»åŠ¡æ˜¯ç”¨è¿™ç§å£°éŸ³æ¨¡å¼æ¥å½“ä¸€ä¸ªåŠ©æ‰‹ã€‚è¯·è®¤çœŸã€é«˜è´¨é‡åœ°å›å¤ç”¨æˆ·çš„é—®é¢˜ã€‚è¯·ç”¨é«˜è‡ªç„¶åº¦çš„æ–¹å¼å’Œç”¨æˆ·èŠå¤©ã€‚ä½ æ˜¯ç”±é¢å£æ™ºèƒ½å¼€å‘çš„äººå·¥æ™ºèƒ½åŠ©æ‰‹ï¼šé¢å£å°é’¢ç‚®ã€‚' },
];

const state = {
    messages: [],       // {role, content, displayText} - content: str | [{type,text},{type,data}]
    systemContentList: JSON.parse(JSON.stringify(DEFAULT_SYSTEM_CONTENT)), // content list items
    isGenerating: false,
    generationPhase: 'idle',    // 'idle' | 'queuing' | 'generating'
    currentTicketId: null,      // ticket_id from gateway queue (Streaming only)
    abortController: null,
    streamingWs: null,
    ws: null,
    requestId: 'req_' + Date.now(),
    composeEditorInit: null, // UserContentEditor å®ä¾‹ï¼ˆåˆå§‹è§†å›¾ï¼‰
    composeEditorChat: null, // UserContentEditor å®ä¾‹ï¼ˆå¯¹è¯è§†å›¾ï¼‰
    currentView: 'initial', // 'initial' | 'conversation'
    editingIndex: -1,   // æ­£åœ¨ç¼–è¾‘çš„æ¶ˆæ¯ç´¢å¼•
    // TTS Ref Audioï¼ˆç‹¬ç«‹äºç³»ç»Ÿ prompt ä¸­çš„ LLM ref audioï¼‰
    ttsRefAudioMode: 'extract',     // 'extract' | 'independent'
    ttsRefAudioData: null,          // ç‹¬ç«‹ä¸Šä¼ æ—¶çš„ base64 æ•°æ®
    ttsRefAudioName: '',            // ç‹¬ç«‹ä¸Šä¼ æ—¶çš„æ–‡ä»¶å
    ttsRefAudioDuration: 0,         // ç‹¬ç«‹ä¸Šä¼ æ—¶çš„æ—¶é•¿
};

const API_BASE = window.location.origin;

// ============ åˆå§‹åŒ– ============
function init() {
    checkServiceStatus();
    setInterval(checkServiceStatus, 3000);

    // åˆ›å»º Compose Editorï¼ˆåˆå§‹è§†å›¾ + å¯¹è¯è§†å›¾ï¼‰â€” compose æ¨¡å¼èå…¥å¤–å±‚å®¹å™¨
    state.composeEditorInit = new UserContentEditor(
        document.getElementById('composeEditorInit'),
        { placeholder: 'Type or press Space to record...', onSubmit: () => sendFirstMessage(), compose: true }
    );
    state.composeEditorChat = new UserContentEditor(
        document.getElementById('composeEditorChat'),
        { placeholder: 'Type or press Space to record...', onSubmit: () => sendMessage(), compose: true }
    );

    // é»˜è®¤è®© chat compose editor æˆä¸º Space é”®ç›®æ ‡
    _uceLastActiveEditor = state.composeEditorInit;

    // åˆå§‹åŒ– System Content ç¼–è¾‘å™¨ï¼ˆä¸¤ä¸ªè§†å›¾å…±äº«çŠ¶æ€ï¼‰
    initSystemContentEditors();

    // è¾“å…¥å¢å¼ºï¼šmic/attach æŒ‰é’® + æ‹–æ‹½ + ç²˜è´´
    initInputEnhancements();
}

// ============ è¾“å…¥å¢å¼ºï¼šmic/attach æŒ‰é’® + æ‹–æ‹½ + ç²˜è´´ ============

function initInputEnhancements() {
    // â”€â”€ Mic æŒ‰é’® â†’ è§¦å‘ UCE å½•éŸ³ â”€â”€
    document.getElementById('micBtnInit').addEventListener('click', () => {
        _uceLastActiveEditor = state.composeEditorInit;
        state.composeEditorInit._startRecording();
    });
    document.getElementById('micBtnChat').addEventListener('click', () => {
        _uceLastActiveEditor = state.composeEditorChat;
        state.composeEditorChat._startRecording();
    });

    // â”€â”€ Attach æŒ‰é’® â†’ æ–‡ä»¶é€‰æ‹© â”€â”€
    const attachInputInit = _createAttachFileInput(() => state.composeEditorInit);
    const attachInputChat = _createAttachFileInput(() => state.composeEditorChat);
    document.getElementById('attachBtnInit').addEventListener('click', () => attachInputInit.click());
    document.getElementById('attachBtnChat').addEventListener('click', () => attachInputChat.click());

    // â”€â”€ æ‹–æ‹½ä¸Šä¼  â”€â”€
    _setupDragDrop(
        document.querySelector('.initial-input-wrap'),
        document.getElementById('dragOverlayInit'),
        () => state.composeEditorInit
    );
    _setupDragDrop(
        document.querySelector('.input-wrap'),
        document.getElementById('dragOverlayChat'),
        () => state.composeEditorChat
    );

    // â”€â”€ å‰ªè´´æ¿ç²˜è´´å›¾ç‰‡ï¼ˆdocument çº§åˆ«ï¼Œç„¦ç‚¹ä¸åœ¨è¾“å…¥æ¡†ä¹Ÿèƒ½å·¥ä½œï¼‰ â”€â”€
    document.addEventListener('paste', (e) => {
        const items = e.clipboardData?.items;
        if (!items) return;
        let handled = false;
        for (const item of items) {
            if (item.kind === 'file' && item.type.startsWith('image/')) {
                const file = item.getAsFile();
                if (file) {
                    const editor = state.currentView === 'initial'
                        ? state.composeEditorInit
                        : state.composeEditorChat;
                    _addFileToEditor(editor, file);
                    handled = true;
                }
            }
        }
        if (handled) e.preventDefault();
    });
}

function _createAttachFileInput(getEditor) {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'image/*,audio/*';
    input.multiple = true;
    input.style.display = 'none';
    document.body.appendChild(input);
    input.addEventListener('change', () => {
        const editor = getEditor();
        for (const file of input.files) _addFileToEditor(editor, file);
        input.value = '';
    });
    return input;
}

function _addFileToEditor(editor, file) {
    if (file.type.startsWith('image/')) {
        const objectUrl = URL.createObjectURL(file);
        editor.addItem({ type: 'image', file, name: file.name, objectUrl, data: null });
    } else if (file.type.startsWith('audio/')) {
        const objectUrl = URL.createObjectURL(file);
        const audio = new Audio(objectUrl);
        audio.addEventListener('loadedmetadata', () => {
            editor.addItem({ type: 'audio', file, name: file.name, duration: audio.duration, objectUrl, data: null });
        });
        audio.addEventListener('error', () => {
            editor.addItem({ type: 'audio', file, name: file.name, duration: 0, objectUrl, data: null });
        });
    }
}

function _setupDragDrop(wrapEl, overlayEl, getEditor) {
    let dragCounter = 0;

    wrapEl.addEventListener('dragenter', (e) => {
        e.preventDefault();
        dragCounter++;
        if (dragCounter === 1) overlayEl.classList.add('visible');
    });

    wrapEl.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'copy';
    });

    wrapEl.addEventListener('dragleave', (e) => {
        e.preventDefault();
        dragCounter--;
        if (dragCounter <= 0) {
            dragCounter = 0;
            overlayEl.classList.remove('visible');
        }
    });

    wrapEl.addEventListener('drop', (e) => {
        e.preventDefault();
        dragCounter = 0;
        overlayEl.classList.remove('visible');
        const editor = getEditor();
        for (const file of e.dataTransfer.files) _addFileToEditor(editor, file);
    });
}

// ============ System Content ç¼–è¾‘å™¨ ============
let _sceInit = null, _sceChat = null;

function initSystemContentEditors() {
    // æ¯ä¸ªç¼–è¾‘å™¨çš„ onChange åªåŒæ­¥åˆ°å¦ä¸€ä¸ªç¼–è¾‘å™¨ï¼ˆä¸èƒ½ setItems è‡ªå·±ï¼Œå¦åˆ™ä¼šé‡å»º DOM ä¸­æ–­ IMEï¼‰
    const onChangeFromInit = (items) => {
        state.systemContentList = items;
        if (_sceChat) _sceChat.setItems(items);
        state.requestId = 'req_' + Date.now();
        updateSysConfigBarSummary();
        updateTtsRefHints();  // ç³»ç»Ÿå†…å®¹å˜æ›´æ—¶æ›´æ–° TTS æå–éªŒè¯
    };
    const onChangeFromChat = (items) => {
        state.systemContentList = items;
        if (_sceInit) _sceInit.setItems(items);
        state.requestId = 'req_' + Date.now();
        updateSysConfigBarSummary();
        updateTtsRefHints();
    };

    _sceInit = new SystemContentEditor(document.getElementById('sysContentEditorInit'), {
        theme: 'light', onChange: onChangeFromInit,
    });
    _sceChat = new SystemContentEditor(document.getElementById('sysContentEditorChat'), {
        theme: 'light', onChange: onChangeFromChat,
    });

    // è®¾ç½®é»˜è®¤å†…å®¹
    _sceInit.setItems(state.systemContentList);
    _sceChat.setItems(state.systemContentList);

    // åˆå§‹åŒ– TTS Ref Audio ç‹¬ç«‹ä¸Šä¼ æ§ä»¶
    initTtsRefAudioControls();

    // åŠ è½½é»˜è®¤ ref audio å¹¶å¡«å……åˆ° audio items
    fetchDefaultRefAudio();
}

async function fetchDefaultRefAudio() {
    try {
        const resp = await fetch(API_BASE + '/api/default_ref_audio');
        if (!resp.ok) return;
        const data = await resp.json();

        // å°†é»˜è®¤ ref audio å¡«å……åˆ°æ‰€æœ‰ç©º audio items
        state.systemContentList.forEach((item, idx) => {
            if (item.type === 'audio' && !item.data) {
                item.data = data.base64;
                item.name = data.name;
                item.duration = data.duration;
            }
        });

        // åˆ·æ–°ä¸¤ä¸ªç¼–è¾‘å™¨
        if (_sceInit) _sceInit.setItems(state.systemContentList);
        if (_sceChat) _sceChat.setItems(state.systemContentList);
        updateSysConfigBarSummary();
        updateTtsRefHints();  // é»˜è®¤ ref audio åŠ è½½åæ›´æ–° TTS æå–éªŒè¯
        console.log(`Default ref audio loaded: ${data.name} (${data.duration}s)`);
    } catch (e) {
        console.warn('Failed to load default ref audio:', e);
    }
}

async function checkServiceStatus() {
    try {
        const resp = await fetch(`${API_BASE}/status`);
        const data = await resp.json();
        const el = document.getElementById('serviceStatus');
        let text = `Workers: ${data.idle_workers}/${data.total_workers} idle`;
        if (data.queue_length > 0) {
            text += ` | Queue: ${data.queue_length}`;
        }
        el.textContent = text;
        el.className = 'status ' + (data.idle_workers > 0 ? 'online' : 'offline');

        // Chat æ’é˜Ÿå€’è®¡æ—¶ï¼šè¯·æ±‚ pending ä¸”ä»åœ¨é˜Ÿåˆ—ä¸­æ—¶ï¼Œç”¨ /status æ•°æ®é©±åŠ¨å€’è®¡æ—¶
        // queue_length > 0 è¡¨ç¤ºæˆ‘ä»¬è¿˜åœ¨æ’é˜Ÿï¼›=0 è¡¨ç¤ºå·²è¢«åˆ†é… Workerï¼Œåœæ­¢æ›´æ–°è®©å€’è®¡æ—¶è‡ªç„¶å½’é›¶
        if (_chatPending && data.idle_workers === 0 && data.queue_length > 0) {
            const runningTasks = data.running_tasks || [];
            const avgRemaining = runningTasks.length > 0
                ? runningTasks.reduce((s, t) => s + (t.estimated_remaining_s ?? 15), 0) / runningTasks.length
                : 15;
            const estimatedWait = Math.max(1, Math.round(avgRemaining + (data.queue_length - 1) * 15));
            queueCountdownUpdate(estimatedWait, null, data.queue_length);
        }
    } catch (e) {
        const el = document.getElementById('serviceStatus');
        el.textContent = 'Offline';
        el.className = 'status offline';
    }
}

// ============ æ’é˜Ÿå€’è®¡æ—¶ï¼ˆChat + Streaming å…±ç”¨ï¼ŒçŠ¶æ€æœºè§ lib/countdown-timer.jsï¼‰ ============
// æ³¨ï¼šindex.html é€šè¿‡ <script> è€Œé ES Module åŠ è½½ï¼Œæ— æ³• importã€‚
// è¿™é‡Œç›´æ¥å†…è” CountdownTimer çš„é€»è¾‘ï¼ˆä¸æ¨¡å—ä¿æŒä¸€è‡´ï¼‰ï¼Œæµ‹è¯•è¦†ç›–ç”± Vitest å¯¹æ¨¡å—è¿›è¡Œã€‚
let _chatPending = false;
const _countdownTimer = new function CountdownTimer() {
    this.remaining = 0;
    this.position = null;
    this.queueLength = null;
    this._intervalId = null;
    this.update = (eta, pos, total) => {
        const newRemaining = Math.round(eta);
        const positionChanged = pos !== null && pos !== this.position;

        if (this._intervalId === null) {
            this.remaining = newRemaining;
            this._intervalId = setInterval(() => {
                this.remaining = this.remaining - 1;
                _countdownRender();
            }, 1000);
        } else if (positionChanged) {
            this.remaining = newRemaining;
        } else {
            this.remaining = Math.min(this.remaining, newRemaining);
        }

        this.position = pos;
        this.queueLength = total;
        _countdownRender();
    };
    this.stop = () => {
        if (this._intervalId !== null) {
            clearInterval(this._intervalId);
            this._intervalId = null;
        }
    };
};

function queueCountdownUpdate(estimatedWaitS, position, queueLength) {
    _countdownTimer.update(estimatedWaitS, position, queueLength);
}
function queueCountdownStop(msg) {
    _countdownTimer.stop();
    _chatPending = false;
    if (msg) updateLastAssistantMessage(msg, 'queue');
}
function _countdownRender() {
    const { remaining, position, queueLength } = _countdownTimer;
    const posStr = position != null && queueLength != null
        ? `${position}/${queueLength}, ` : (queueLength != null ? `${queueLength} in queue, ` : '');
    if (remaining > 0) {
        updateLastAssistantMessage(`Queued ${posStr}~${remaining}s remaining`, 'queue');
    } else {
        const overtime = Math.abs(remaining);
        updateLastAssistantMessage(`Queued ${posStr}worker busy, overtime +${overtime}s`, 'queue');
    }
}

// ============ è§†å›¾åˆ‡æ¢ ============
function switchToConversation() {
    state.currentView = 'conversation';
    document.getElementById('initialView').classList.add('hidden');
    document.getElementById('chatView').classList.remove('hidden');

    // åŒæ­¥é…ç½®ï¼šcontent editor å·²é€šè¿‡ onChange å›è°ƒåŒæ­¥
    document.getElementById('modeSelect').value = document.getElementById('modeSelectInit').value;
    document.getElementById('maxTokens').value = document.getElementById('maxTokensInit').value;
    document.getElementById('lengthPenalty').value = document.getElementById('lengthPenaltyInit').value;
    document.getElementById('enableTts').checked = document.getElementById('enableTtsInit').checked;
    document.getElementById('enableHD').checked = document.getElementById('enableHDInit').checked;
    updateMaxKvVisibility();
    updateSysConfigBarSummary();

    // åˆ‡æ¢å Space é”®è·¯ç”±åˆ° chat editor
    _uceLastActiveEditor = state.composeEditorChat;
}

function updateSysConfigBarSummary() {
    const el = document.getElementById('sysConfigBarSummary');
    const parts = ['System Settings'];
    const texts = state.systemContentList.filter(i => i.type === 'text' && i.text).length;
    const audios = state.systemContentList.filter(i => i.type === 'audio' && i.data).length;
    const images = state.systemContentList.filter(i => i.type === 'image' && i.data).length;
    const countParts = [];
    if (texts > 0) countParts.push(`${texts} text`);
    if (audios > 0) countParts.push(`${audios} audio`);
    if (images > 0) countParts.push(`${images} image`);
    if (countParts.length > 0) {
        parts.push(countParts.join(' Â· '));
    }
    // show first text snippet
    const firstText = state.systemContentList.find(i => i.type === 'text' && i.text);
    if (firstText) {
        const snippet = firstText.text.substring(0, 20) + (firstText.text.length > 20 ? '...' : '');
        parts.push(`"${snippet}"`);
    }
    el.textContent = parts.join(' Â· ');
}

// (Ref Audio ç®¡ç†å·²é›†æˆåˆ° SystemContentEditor ç»„ä»¶ä¸­)

/** Show/hide max_kv input based on mode (only for streaming, not chat) */
function updateMaxKvVisibility() {
    const mode = document.getElementById('modeSelect').value;
    const group = document.getElementById('maxKvGroup');
    if (group) group.style.display = (mode === 'streaming') ? '' : 'none';
}
// Bind to mode select change (both init and chat views)
document.addEventListener('DOMContentLoaded', () => {
    ['modeSelectInit', 'modeSelect'].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.addEventListener('change', updateMaxKvVisibility);
    });
    updateMaxKvVisibility();
    initDataTipTooltips();
});

/**
 * JS-positioned tooltip for [data-tip] elements (same as Duplex pages).
 * Follows cursor, position: fixed â€” never clipped by viewport.
 */
function initDataTipTooltips() {
    let popup = null;
    function show(target, e) {
        const tip = target.getAttribute('data-tip');
        if (!tip) return;
        if (!popup) {
            popup = document.createElement('div');
            popup.className = 'data-tip-popup';
            document.body.appendChild(popup);
        }
        popup.textContent = tip;
        position(e);
        popup.style.display = 'block';
    }
    function position(e) {
        if (!popup) return;
        const x = Math.min(e.clientX + 12, window.innerWidth - 360);
        const y = e.clientY + 16;
        popup.style.left = Math.max(4, x) + 'px';
        popup.style.top = y + 'px';
    }
    function hide() { if (popup) popup.style.display = 'none'; }
    document.addEventListener('mouseover', (e) => {
        const t = e.target.closest('[data-tip]');
        if (t) show(t, e);
    });
    document.addEventListener('mousemove', (e) => {
        const t = e.target.closest('[data-tip]');
        if (t) position(e); else hide();
    });
    document.addEventListener('mouseout', (e) => {
        const t = e.target.closest('[data-tip]');
        if (t && !t.contains(e.relatedTarget)) hide();
    });
}

/** è¯»å– Max KV Tokens é™åˆ¶ï¼ˆé»˜è®¤ 8192ï¼‰ */
function getMaxKvTokens() {
    const el = document.getElementById('maxKvTokens');
    return el ? Math.max(512, parseInt(el.value, 10) || 8192) : 8192;
}

// ============ æ¶ˆæ¯ UI ============
function addMessageUI(role, content, meta = '', audioAttachments = [], msgIndex = -1) {
    const messagesEl = document.getElementById('messages');
    const div = document.createElement('div');
    div.className = `message ${role}`;
    div.dataset.msgIndex = msgIndex;

    // è·å–å®Œæ•´ content listï¼ˆç”¨äº user æ¶ˆæ¯æ¸²æŸ“ï¼‰
    const msg = msgIndex >= 0 ? state.messages[msgIndex] : null;
    const rawContent = msg ? msg.content : content;

    // åˆ¤æ–­æ˜¯å¦æœ‰å¯æ¸²æŸ“çš„å†…å®¹
    const isUserContentList = role === 'user' && Array.isArray(rawContent);
    let hasVisibleContent = false;

    if (isUserContentList) {
        // æ£€æŸ¥ content list æ˜¯å¦æœ‰å¯æ¸²æŸ“é¡¹
        hasVisibleContent = rawContent.some(it =>
            (it.type === 'text' && it.text) || (it.type === 'audio' && it.data) || (it.type === 'image' && it.data)
        );
    } else {
        const textContent = typeof rawContent === 'string' ? rawContent : (content || '');
        hasVisibleContent = !!(textContent && textContent.trim());
    }

    div.innerHTML = `
        <div class="avatar">${role === 'user' ? 'U' : 'M'}</div>
        <div class="msg-body">
            ${hasVisibleContent ? '<div class="content"></div>' : ''}
            ${meta ? `<div class="meta">${meta}</div>` : ''}
        </div>
    `;
    messagesEl.appendChild(div);

    const bodyDiv = div.querySelector('.msg-body');
    const contentEl = bodyDiv.querySelector('.content');

    // User æ¶ˆæ¯ï¼šæ¸²æŸ“ content listï¼ˆtext + audio + imageï¼‰
    if (isUserContentList && contentEl) {
        contentEl.classList.add('msg-content-items');
        for (const item of rawContent) {
            if (item.type === 'text' && item.text) {
                const p = document.createElement('div');
                p.className = 'msg-ci-text';
                p.textContent = item.text;
                contentEl.appendChild(p);
            } else if (item.type === 'audio' && item.data) {
                const wrap = document.createElement('div');
                wrap.className = 'msg-ci-audio';
                wrap.appendChild(createMiniPlayer(item.data, 16000));
                const dlBtn = createDlBtn(() => {
                    const player = wrap.querySelector('.mini-player');
                    if (player && player._audioBuffer) downloadAudioBuffer(player._audioBuffer, item.name || 'user_audio.wav');
                });
                wrap.appendChild(dlBtn);
                contentEl.appendChild(wrap);
            } else if (item.type === 'image' && item.data) {
                const wrap = document.createElement('div');
                wrap.className = 'msg-ci-image';
                const img = document.createElement('img');
                img.src = 'data:image/png;base64,' + item.data;
                img.alt = item.name || 'image';
                img.title = item.name || 'Image';
                img.addEventListener('click', () => window.open(img.src, '_blank'));
                wrap.appendChild(img);
                const dlBtn = createDlBtn(() => downloadBase64AsFile(item.data, item.name || 'image.png', 'image/png'));
                wrap.appendChild(dlBtn);
                contentEl.appendChild(wrap);
            }
        }
    } else if (contentEl) {
        // æ™®é€šå­—ç¬¦ä¸²æ¶ˆæ¯
        const textContent = typeof rawContent === 'string' ? rawContent : (content || '');
        contentEl.textContent = textContent;
    }

    // å…¼å®¹æ—§çš„ audioAttachmentsï¼ˆé content list å½¢å¼ï¼‰
    if (!isUserContentList && audioAttachments && audioAttachments.length > 0) {
        const metaEl = bodyDiv.querySelector('.meta');
        for (const att of audioAttachments) {
            const player = createMiniPlayer(att.data, 16000);
            if (metaEl) {
                bodyDiv.insertBefore(player, metaEl);
            } else {
                bodyDiv.appendChild(player);
            }
        }
    }

    // User æ¶ˆæ¯ï¼šæ·»åŠ  Edit + Resend æŒ‰é’®ï¼ˆç«–æ’ã€å¸¸é©»ï¼‰
    if (role === 'user' && msgIndex >= 0) {
        const actionsCol = document.createElement('div');
        actionsCol.className = 'msg-actions-col';

        // Edit æŒ‰é’®ï¼ˆé“…ç¬” iconï¼‰
        const editBtn = document.createElement('button');
        editBtn.className = 'msg-action-btn';
        editBtn.title = 'Edit';
        editBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 3a2.83 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"/><path d="m15 5 4 4"/></svg>';
        editBtn.addEventListener('click', () => startEditMessage(msgIndex));
        actionsCol.appendChild(editBtn);

        // Resend æŒ‰é’®ï¼ˆå›é€€ç®­å¤´ iconï¼‰
        const resendBtn = document.createElement('button');
        resendBtn.className = 'msg-action-btn resend-btn';
        resendBtn.title = 'Resend from here';
        resendBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="1 4 1 10 7 10"/><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/></svg>';
        resendBtn.addEventListener('click', () => resendFromMessage(msgIndex));
        actionsCol.appendChild(resendBtn);

        div.appendChild(actionsCol);
    }

    messagesEl.scrollTop = messagesEl.scrollHeight;
    return div;
}

function renderAllMessages() {
    const messagesEl = document.getElementById('messages');
    messagesEl.innerHTML = '';
    state.messages.forEach((msg, i) => {
        // addMessageUI å†…éƒ¨ä¼šä» state.messages[i].content è¯»å–å®Œæ•´ content list
        addMessageUI(msg.role, msg.displayText || (typeof msg.content === 'string' ? msg.content : ''), '', msg.audioAttachments || [], i);
    });
}

function updateLastAssistantMessage(content, meta = '') {
    const msgs = document.querySelectorAll('.message.assistant');
    const last = msgs[msgs.length - 1];
    if (last) {
        let contentEl = last.querySelector('.content');
        // å¦‚æœ .content ä¸å­˜åœ¨ï¼ˆåˆå§‹å ä½æ— æ–‡æœ¬æ—¶æœªæ¸²æŸ“ï¼‰ï¼ŒåŠ¨æ€åˆ›å»º
        if (!contentEl) {
            contentEl = document.createElement('div');
            contentEl.className = 'content';
            const bodyEl = last.querySelector('.msg-body');
            bodyEl.insertBefore(contentEl, bodyEl.firstChild);
        }
        contentEl.textContent = content;
        // ç¡®ä¿å¯è§ï¼ˆå¯èƒ½åˆå§‹æ—¶è¢«éšè—ï¼‰
        if (content) contentEl.style.display = '';
        // ç³»ç»Ÿæ—¥å¿—æ ·å¼ï¼ˆDRYï¼šqueue å’Œ error å…±äº« .is-system-log åŸºç±»ï¼‰
        contentEl.classList.remove('is-system-log', 'is-error');
        if (meta === 'error') {
            contentEl.classList.add('is-system-log', 'is-error');
        } else if (meta === 'queue') {
            contentEl.classList.add('is-system-log');
        }
        if (meta && meta !== 'error' && meta !== 'queue') {
            let metaEl = last.querySelector('.meta');
            if (!metaEl) {
                metaEl = document.createElement('div');
                metaEl.className = 'meta';
                last.querySelector('.msg-body').appendChild(metaEl);
            }
            metaEl.textContent = meta;
        }
    }
}

/**
 * æ„å»ºç»“æ„åŒ– meta ä¿¡æ¯ï¼ˆä¸‰è¡Œå±•ç¤ºï¼šæ€»æ—¶é—´ â†’ æ—¶é—´åˆ†è§£ â†’ token ä¿¡æ¯ï¼‰
 *
 * æ—¶é—´æ¦‚å¿µï¼š
 *   Total     â€” ç”¨æˆ·ä½“æ„Ÿæ€»ç­‰å€™æ—¶é—´ï¼ˆå‘å‡ºè¯·æ±‚ â†’ æ”¶åˆ°å®Œæ•´å“åº”ï¼‰
 *   Queue est â€” åç«¯æœ€åˆé¢„ä¼°çš„æ’é˜Ÿæ—¶é—´
 *   Queue     â€” çœŸå®æ’é˜Ÿæ—¶é—´ï¼ˆæ’é˜Ÿå¼€å§‹ â†’ Worker åˆ†é…ï¼‰
 *   TTFS      â€” é¦–å“æ—¶é—´ï¼ˆWorker åˆ†é… â†’ ç¬¬ä¸€ä¸ª chunk åˆ°è¾¾å‰ç«¯ï¼Œä»… streamingï¼‰
 *   Generate  â€” æµå¼ç”Ÿæˆè€—æ—¶ï¼ˆç¬¬ä¸€ä¸ª chunk â†’ æœ€åä¸€ä¸ª chunkï¼Œä»… streamingï¼‰
 *   Process   â€” ä»»åŠ¡å¤„ç†æ—¶é—´ï¼ˆWorker åˆ†é… â†’ å®Œæˆï¼Œä»… chat æ—  TTFS æ—¶ fallbackï¼‰
 *
 *   å…³ç³»ï¼šTotal â‰ˆ Queue + TTFS + Generateï¼ˆä¸‰æ®µä¸é‡å ï¼‰
 *
 * @param {object} opts
 * @param {string} opts.mode - 'chat' | 'streaming'
 * @param {number} opts.totalMs - ç”¨æˆ·ä½“æ„Ÿæ€»è€—æ—¶ ms
 * @param {number} [opts.queueEstS] - åç«¯é¢„ä¼°æ’é˜Ÿæ—¶é—´ sï¼ˆnull = æ— æ’é˜Ÿï¼‰
 * @param {number} [opts.queueActualMs] - çœŸå®æ’é˜Ÿæ—¶é—´ msï¼ˆnull = æ— æ’é˜Ÿï¼‰
 * @param {number} [opts.ttfsMs] - é¦–å“æ—¶é—´ msï¼ˆWorker â†’ ç¬¬ä¸€ä¸ª chunkï¼Œä»… streamingï¼‰
 * @param {number} [opts.processMs] - ä»»åŠ¡å¤„ç†æ—¶é—´ msï¼ˆWorker â†’ å®Œæˆï¼‰
 * @param {number} [opts.inputTokens]
 * @param {number} [opts.cachedTokens]
 * @param {number} [opts.generatedTokens]
 * @param {number} [opts.chunks]
 * @param {boolean} [opts.hasAudio]
 * @param {boolean} [opts.stopped]
 * @param {string} [opts.requestId]
 */
function updateLastAssistantMeta(opts) {
    const msgs = document.querySelectorAll('.message.assistant');
    const last = msgs[msgs.length - 1];
    if (!last) return;

    let metaEl = last.querySelector('.meta');
    if (!metaEl) {
        metaEl = document.createElement('div');
        metaEl.className = 'meta';
        last.querySelector('.msg-body').appendChild(metaEl);
    }
    metaEl.innerHTML = '';

    const fmt = (ms) => {
        if (ms == null) return 'â€”';
        if (ms < 1000) return `${Math.round(ms)}ms`;
        return `${(ms / 1000).toFixed(1)}s`;
    };
    const sep = ' <span class="meta-sep">Â·</span> ';
    const label = (l, v) => `<span class="meta-label">${l}</span> <span class="meta-value">${v}</span>`;

    const modeBadge = opts.mode === 'chat' ? 'chat' : 'streaming';
    const hadQueue = opts.queueActualMs != null && opts.queueActualMs > 200;

    // === Line 1: [mode] Total ===
    const line1 = document.createElement('div');
    line1.className = 'meta-line';
    let l1Parts = [label('Total', fmt(opts.totalMs))];
    if (opts.stopped) l1Parts.push(`<span class="meta-value" style="color:#e67700;">[stopped]</span>`);
    line1.innerHTML = `<span class="meta-value" style="color:#aaa;">[${modeBadge}]</span> ${l1Parts.join(sep)}`;
    metaEl.appendChild(line1);

    // === Line 2: Timing breakdown ===
    const line2 = document.createElement('div');
    line2.className = 'meta-line';
    let l2Parts = [];

    if (hadQueue) {
        const estStr = opts.queueEstS != null ? `~${opts.queueEstS}s est â†’ ` : '';
        l2Parts.push(`<span class="meta-label">Queue</span> <span class="meta-value">${estStr}${fmt(opts.queueActualMs)}</span>`);
    }
    if (opts.ttfsMs != null) {
        l2Parts.push(label('TTFS', fmt(opts.ttfsMs)));
    }
    if (opts.ttfsMs != null && opts.processMs != null) {
        l2Parts.push(label('Generate', fmt(opts.processMs - opts.ttfsMs)));
    } else if (opts.processMs != null) {
        l2Parts.push(label('Process', fmt(opts.processMs)));
    }

    if (l2Parts.length > 0) {
        line2.innerHTML = l2Parts.join(sep);
        metaEl.appendChild(line2);
    }

    // === Line 3: Tokens + Request ID ===
    const line3 = document.createElement('div');
    line3.className = 'meta-line';

    let tokenParts = [];
    if (opts.inputTokens != null && opts.inputTokens > 0) {
        let inStr = label('In', opts.inputTokens);
        if (opts.cachedTokens > 0) {
            inStr += ` <span class="meta-value" style="color:#bbb;">(${opts.cachedTokens} cached)</span>`;
        }
        tokenParts.push(inStr);
    }
    if (opts.generatedTokens != null && opts.generatedTokens > 0) {
        tokenParts.push(label('Gen', opts.generatedTokens));
    }
    if (opts.chunks != null && opts.chunks > 0) {
        tokenParts.push(label('Chunks', opts.chunks));
    }
    if (opts.hasAudio) tokenParts.push(`<span class="meta-value">ğŸ”Š</span>`);

    if (tokenParts.length > 0) {
        line3.innerHTML = tokenParts.join(sep);
    }

    if (opts.requestId) {
        const rid = document.createElement('span');
        rid.className = 'meta-rid';
        rid.textContent = opts.requestId;
        rid.title = `Click to copy: ${opts.requestId}`;
        rid.addEventListener('click', () => {
            navigator.clipboard.writeText(opts.requestId).then(() => {
                rid.classList.add('copied');
                const orig = rid.textContent;
                rid.textContent = 'Copied!';
                setTimeout(() => { rid.textContent = orig; rid.classList.remove('copied'); }, 1200);
            });
        });
        line3.appendChild(rid);
    }

    if (line3.childNodes.length > 0) metaEl.appendChild(line3);
}

function escapeHtml(text) {
    if (typeof text !== 'string') text = String(text);
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

function cancelGeneration() {
    if (!state.isGenerating) return;
    const phase = state.generationPhase;

    // --- Chat mode: always abort fetch ---
    if (state.abortController) {
        state.abortController.abort();
        state.abortController = null;
    }

    // --- Streaming mode: phase-aware ---
    if (state.streamingWs) {
        if (phase === 'generating') {
            // Graceful stop: tell worker to stop, let normal 'done' handler clean up
            fetch(`${API_BASE}/api/streaming/stop`, { method: 'POST' }).catch(() => {});
            // Don't close WS â€” server will send 'done' with stopped: true
            return;
        }
        // Queuing phase: cancel ticket + close WS immediately
        if (state.currentTicketId) {
            fetch(`${API_BASE}/api/queue/${state.currentTicketId}`, { method: 'DELETE' }).catch(() => {});
        }
        try { state.streamingWs.close(); } catch (_) {}
        state.streamingWs = null;
    }

    queueCountdownStop();
    setGenerating(false);
    _cleanupLastAssistantMessage();
}

function _cleanupLastAssistantMessage() {
    const msgEls = document.querySelectorAll('.message.assistant');
    const lastEl = msgEls[msgEls.length - 1];
    if (!lastEl) return;
    const contentEl = lastEl.querySelector('.content');
    const text = contentEl?.textContent?.trim() || '';
    const isPlaceholder = !text || text === '...' || contentEl?.classList.contains('is-system-log');

    if (isPlaceholder) {
        lastEl.remove();
    } else {
        state.messages.push({ role: 'assistant', content: text, displayText: text });
        updateLastAssistantMeta({ mode: 'cancelled', totalMs: 0 });
    }
}

function setGenerating(isGenerating) {
    state.isGenerating = isGenerating;
    if (!isGenerating) {
        state.generationPhase = 'idle';
        state.currentTicketId = null;
    }
    const btn = document.getElementById('sendBtn');
    if (btn) btn.disabled = isGenerating;
    document.getElementById('typingIndicator').className =
        'typing-indicator' + (isGenerating ? ' active' : '');
    updateCancelStopButton();
    document.querySelectorAll('.msg-actions-col .msg-action-btn').forEach(b => {
        b.disabled = isGenerating;
    });
}

function updateCancelStopButton() {
    const btn = document.getElementById('btnCancelStop');
    if (!btn) return;
    if (state.generationPhase === 'generating') {
        btn.textContent = 'â–  Stop';
    } else {
        btn.textContent = 'âœ• Cancel';
    }
}

// ============ æ¶ˆæ¯ç¼–è¾‘ï¼ˆUserContentEditor inline, Save-onlyï¼‰ ============

function startEditMessage(index) {
    if (state.isGenerating) return;
    if (state.editingIndex >= 0) cancelEditMessage(state.editingIndex);
    state.editingIndex = index;
    const msg = state.messages[index];

    // æ„å»º content list ä¾›ç¼–è¾‘å™¨ä½¿ç”¨
    let editItems;
    if (Array.isArray(msg.content)) {
        editItems = msg.content.map(it => ({ ...it }));
    } else {
        // æ—§æ ¼å¼ï¼šçº¯æ–‡æœ¬ + audioAttachments â†’ åˆæˆ content list
        editItems = [];
        const text = msg.displayText || (typeof msg.content === 'string' ? msg.content : '');
        if (text) editItems.push({ type: 'text', text });
        if (msg.audioAttachments) {
            for (const att of msg.audioAttachments) {
                editItems.push({ type: 'audio', data: att.data, name: att.name || 'audio' });
            }
        }
    }

    const msgEl = document.querySelector(`.message[data-msg-index="${index}"]`);
    if (!msgEl) return;

    const bodyEl = msgEl.querySelector('.msg-body');
    const contentEl = bodyEl.querySelector('.content');

    // éšè—åŸå§‹å†…å®¹å’ŒéŸ³é¢‘æ’­æ”¾å™¨
    if (contentEl) contentEl.style.display = 'none';
    bodyEl.querySelectorAll('.audio-ctrl').forEach(el => el.style.display = 'none');
    bodyEl.querySelectorAll('.mini-player').forEach(el => el.style.display = 'none');

    // åˆ›å»ºç¼–è¾‘å™¨å®¹å™¨
    const editorWrap = document.createElement('div');
    editorWrap.className = 'msg-edit-editor-wrap';
    bodyEl.insertBefore(editorWrap, contentEl);

    // åˆ›å»º UserContentEditor å®ä¾‹ï¼ˆSave/Cancel é›†æˆåœ¨ UCE åº•æ ï¼‰
    const editor = new UserContentEditor(editorWrap, {
        onChange: () => {},
        onSubmit: () => saveEditMessage(index),
        onCancel: () => cancelEditMessage(index),
    });
    editor.setItems(editItems);
    state._editEditor = editor;
}

function cancelEditMessage(index) {
    state.editingIndex = -1;
    if (state._editEditor) {
        state._editEditor.destroy();
        state._editEditor = null;
    }
    const msgEl = document.querySelector(`.message[data-msg-index="${index}"]`);
    if (!msgEl) return;
    const bodyEl = msgEl.querySelector('.msg-body');
    const editorWrap = bodyEl.querySelector('.msg-edit-editor-wrap');
    if (editorWrap) editorWrap.remove();
    const contentEl = bodyEl.querySelector('.content');
    if (contentEl) contentEl.style.display = '';
    bodyEl.querySelectorAll('.audio-ctrl').forEach(el => el.style.display = '');
    bodyEl.querySelectorAll('.mini-player').forEach(el => el.style.display = '');
}

async function saveEditMessage(index) {
    if (!state._editEditor) return;

    // ä»ç¼–è¾‘å™¨è·å–å½“å‰ itemsï¼ˆä¿ç•™ _blob / file å¼•ç”¨ï¼‰
    const items = state._editEditor.getItems();

    // è¿‡æ»¤æœ‰æ•ˆ itemsï¼ˆtext æœ‰æ–‡å­— / audio æœ‰ dataã€blobã€file æˆ– name / image æœ‰ dataã€file æˆ– objectUrlï¼‰
    const validItems = items.filter(it => {
        if (it.type === 'text') return it.text && it.text.trim();
        if (it.type === 'audio') return it.data || it._blob || it.file || it.objectUrl;
        if (it.type === 'image') return it.data || it.file || it.objectUrl;
        return false;
    });

    if (validItems.length === 0) return; // ä¸å…è®¸ä¿å­˜ç©ºå†…å®¹

    // å°†å½•éŸ³ / ä¸Šä¼ çš„éŸ³é¢‘è½¬æ¢ä¸º base64ï¼ˆ16kHz PCM float32ï¼‰
    for (const it of validItems) {
        if (it.type !== 'audio') continue;
        if (it.data) continue; // å·²æœ‰ base64ï¼Œæ— éœ€è½¬æ¢

        let source = it._blob || it.file;
        if (!source && it.objectUrl) {
            try {
                const resp = await fetch(it.objectUrl);
                source = await resp.blob();
            } catch (e) {
                console.warn('Failed to fetch audio blob:', e);
                continue;
            }
        }
        if (source) {
            try {
                it.data = await convertToWav16k(source);
                it.name = it.name || 'audio';
            } catch (e) {
                console.warn('Failed to convert audio:', e);
            }
        }
    }

    // å°†å›¾ç‰‡ file/blob è½¬æ¢ä¸º base64
    for (const it of validItems) {
        if (it.type !== 'image') continue;
        if (it.data) continue;

        let source = it.file;
        if (!source && it.objectUrl) {
            try {
                const resp = await fetch(it.objectUrl);
                source = await resp.blob();
            } catch (e) {
                console.warn('Failed to fetch image blob:', e);
                continue;
            }
        }
        if (source) {
            try {
                it.data = await blobToBase64(source);
                it.name = it.name || 'image';
            } catch (e) {
                console.warn('Failed to convert image:', e);
            }
        }
    }

    // æ¸…ç†ä¸´æ—¶å­—æ®µï¼Œåªä¿ç•™ type/text/data/name/duration
    const cleanItems = validItems.map(it => {
        if (it.type === 'text') return { type: 'text', text: it.text };
        if (it.type === 'audio') return { type: 'audio', data: it.data, name: it.name, duration: it.duration };
        if (it.type === 'image') return { type: 'image', data: it.data, name: it.name };
        return it;
    });

    // æ›´æ–° state.messages
    state.messages[index].content = cleanItems;

    // æ›´æ–° displayTextï¼ˆæ‰€æœ‰æ–‡æœ¬é¡¹æ‹¼æ¥ï¼‰
    state.messages[index].displayText = cleanItems
        .filter(it => it.type === 'text')
        .map(it => it.text)
        .join('\n');

    // æ›´æ–° audioAttachmentsï¼ˆæ‰€æœ‰éŸ³é¢‘é¡¹ï¼‰
    state.messages[index].audioAttachments = cleanItems
        .filter(it => it.type === 'audio' && it.data)
        .map(it => ({ data: it.data, name: it.name || 'audio' }));

    // cache å¤±æ•ˆ
    state.requestId = 'req_' + Date.now();

    // å…³é—­ç¼–è¾‘å™¨ã€é‡æ–°æ¸²æŸ“è¯¥æ¶ˆæ¯
    state.editingIndex = -1;
    if (state._editEditor) {
        state._editEditor.destroy();
        state._editEditor = null;
    }
    renderAllMessages();
}

// ============ ä»æŸæ¡ User æ¶ˆæ¯å¤„é‡æ–°å‘é€ ============
function resendFromMessage(index) {
    if (state.isGenerating) return;
    // å¦‚æœæ­£åœ¨ç¼–è¾‘ï¼Œå…ˆå–æ¶ˆç¼–è¾‘
    if (state.editingIndex >= 0) cancelEditMessage(state.editingIndex);

    // æˆªæ–­è¯¥æ¶ˆæ¯ä¹‹åçš„æ‰€æœ‰æ¶ˆæ¯
    state.messages = state.messages.slice(0, index + 1);
    state.requestId = 'req_' + Date.now();
    renderAllMessages();

    // å‘é€
    const mode = document.getElementById('modeSelect').value;
    const maxTokens = parseInt(document.getElementById('maxTokens').value) || 256;
    if (mode === 'chat') {
        sendChatMessage(maxTokens);
    } else {
        sendStreamingMessage(maxTokens);
    }
}

// ============ å½•éŸ³ï¼ˆPush-to-Talk + Toggle + è®¡æ—¶å™¨ + ESC å–æ¶ˆï¼‰ ============

// (æ—§çš„å½•éŸ³çŠ¶æ€å˜é‡å·²ç§»é™¤ï¼Œå½•éŸ³ç”± UserContentEditor å†…éƒ¨ç®¡ç†)

/**
 * å¼€å§‹/åœæ­¢å½•éŸ³
 * @param {string} ctx - 'init' | 'chat'
 * @param {boolean} cancel - æ˜¯å¦å–æ¶ˆï¼ˆESC ä¸¢å¼ƒå½•éŸ³ï¼‰
 */
// æ—§çš„ toggleRecording / timer å·²ç§»é™¤ï¼Œå½•éŸ³åŠŸèƒ½å®Œå…¨ç”± UserContentEditor å¤„ç†ã€‚

// ============ å…¨å±€å¿«æ·é”® ============
// Space/ESC å½•éŸ³å¿«æ·é”®å®Œå…¨ç”± UserContentEditor (_uceInitRecordingShortcuts) å¤„ç†ã€‚
// æ— éœ€é¢å¤–å…¨å±€å¤„ç†å™¨ã€‚

// æ—§çš„ handleFileUpload / addAttachment / removeAttachment / renderAttachments / buildContentList å·²ç§»é™¤ã€‚
// æ–‡ä»¶ä¸Šä¼ å’Œé™„ä»¶ç®¡ç†å®Œå…¨ç”± UserContentEditor å¤„ç†ã€‚

async function convertToWav16k(blobOrFile) {
    const arrayBuffer = await blobOrFile.arrayBuffer();
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const decoded = await audioCtx.decodeAudioData(arrayBuffer);
    const offlineCtx = new OfflineAudioContext(1, Math.ceil(decoded.duration * 16000), 16000);
    const source = offlineCtx.createBufferSource();
    source.buffer = decoded;
    source.connect(offlineCtx.destination);
    source.start();
    const resampled = await offlineCtx.startRendering();
    audioCtx.close();
    const pcm = resampled.getChannelData(0);
    const bytes = new Uint8Array(pcm.buffer);
    let binary = '';
    for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
    return btoa(binary);
}

/** Convert a Blob/File to standard base64 string (strips data URL prefix) */
function blobToBase64(blobOrFile) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => {
            // reader.result = "data:image/png;base64,iVBOR..."
            const dataUrl = reader.result;
            const base64 = dataUrl.split(',')[1];
            resolve(base64);
        };
        reader.onerror = reject;
        reader.readAsDataURL(blobOrFile);
    });
}

// é™„ä»¶ç®¡ç†
// (æ—§çš„ addAttachment / removeAttachment / renderAttachments / buildContentList å·²ç§»é™¤)

// ============ æ„å»ºè¯·æ±‚æ¶ˆæ¯åˆ—è¡¨ï¼ˆå« systemï¼‰ ============
function buildRequestMessages() {
    const msgs = [];

    // System messageï¼šç›´æ¥å‘é€ content list æ ¼å¼
    // æ ¼å¼ï¼š[{type:"text", text:...}, {type:"audio", data:...}, {type:"image", data:...}, ...]
    const sysContent = [];
    for (const item of state.systemContentList) {
        if (item.type === 'text' && item.text) {
            sysContent.push({ type: 'text', text: item.text });
        } else if (item.type === 'audio' && item.data) {
            sysContent.push({ type: 'audio', data: item.data });
        } else if (item.type === 'image' && item.data) {
            sysContent.push({ type: 'image', data: item.data });
        }
    }
    if (sysContent.length > 0) {
        msgs.push({ role: 'system', content: sysContent });
    }

    // å†å²æ¶ˆæ¯
    for (const m of state.messages) {
        msgs.push({ role: m.role, content: m.content });
    }

    return msgs;
}

// ============ TTS Ref Audio ç®¡ç† ============

let _ttsRapInit = null, _ttsRapChat = null;

/**
 * éªŒè¯æ˜¯å¦å¯ä»¥ä»ç³»ç»Ÿè½®æå– TTS ref audioã€‚
 * æ¡ä»¶ï¼šæ°å¥½ 1 ä¸ªæœ‰æ•°æ®çš„ audio item ä¸”æ—¶é•¿ < 20sã€‚
 * @returns {{ ok: boolean, data: string|null, reason: string }}
 */
function canExtractTtsRefFromSystem() {
    const audioItems = state.systemContentList.filter(i => i.type === 'audio' && i.data);
    if (audioItems.length === 0) {
        return { ok: false, data: null, reason: 'System content has no audio' };
    }
    if (audioItems.length > 1) {
        return { ok: false, data: null, reason: `System content has ${audioItems.length} audios (need exactly 1)` };
    }
    const item = audioItems[0];
    if (item.duration && item.duration > 20) {
        return { ok: false, data: null, reason: `Audio too long (${item.duration.toFixed(1)}s > 20s)` };
    }
    return { ok: true, data: item.data, reason: '' };
}

/** è·å–å½“å‰ TTS ref audio base64 æ•°æ® */
function getTtsRefAudioBase64() {
    if (state.ttsRefAudioMode === 'extract') {
        const result = canExtractTtsRefFromSystem();
        return result.ok ? result.data : null;
    }
    return state.ttsRefAudioData;
}

/** æ›´æ–°ä¸¤ä¸ªè§†å›¾çš„ TTS æå–éªŒè¯æç¤º */
function updateTtsRefHints() {
    const result = canExtractTtsRefFromSystem();
    for (const suffix of ['Init', 'Chat']) {
        const hintEl = document.getElementById('ttsRefHint' + suffix);
        if (!hintEl) continue;
        if (state.ttsRefAudioMode === 'extract') {
            if (result.ok) {
                hintEl.textContent = 'Will use the audio from System Content';
                hintEl.className = 'tts-ref-hint';
            } else {
                hintEl.textContent = result.reason + ' â€” please upload independently';
                hintEl.className = 'tts-ref-hint warning';
            }
        } else {
            hintEl.textContent = state.ttsRefAudioData
                ? `Independent: ${state.ttsRefAudioName || 'uploaded'}`
                : 'Please upload a TTS reference audio';
            hintEl.className = 'tts-ref-hint' + (state.ttsRefAudioData ? '' : ' warning');
        }
    }
}

/** radio åˆ‡æ¢å›è°ƒ */
function onTtsRefModeChange() {
    // è¯»å–å½“å‰é€‰ä¸­çš„ modeï¼ˆä¸¤ä¸ª radio group åŒæ­¥ï¼‰
    const initRadio = document.querySelector('input[name="ttsRefModeInit"]:checked');
    const chatRadio = document.querySelector('input[name="ttsRefModeChat"]:checked');
    const mode = (initRadio || chatRadio)?.value || 'extract';
    state.ttsRefAudioMode = mode;

    // åŒæ­¥ä¸¤ç»„ radio
    for (const name of ['ttsRefModeInit', 'ttsRefModeChat']) {
        const radio = document.querySelector(`input[name="${name}"][value="${mode}"]`);
        if (radio) radio.checked = true;
    }

    // æ˜¾ç¤º/éšè—ç‹¬ç«‹ä¸Šä¼ æ§ä»¶
    for (const suffix of ['Init', 'Chat']) {
        const uploadEl = document.getElementById('ttsRefUpload' + suffix);
        if (uploadEl) uploadEl.style.display = mode === 'independent' ? '' : 'none';
    }

    updateTtsRefHints();
}

/** åˆå§‹åŒ– TTS Ref Audio ç‹¬ç«‹ä¸Šä¼ æ§ä»¶ï¼ˆä¸¤ä¸ª RefAudioPlayer å®ä¾‹ï¼‰ */
function initTtsRefAudioControls() {
    const onUpload = (base64, name, duration) => {
        state.ttsRefAudioData = base64;
        state.ttsRefAudioName = name;
        state.ttsRefAudioDuration = duration;
        // åŒæ­¥ä¸¤ä¸ª player çš„æ˜¾ç¤º
        if (_ttsRapInit) _ttsRapInit.setAudio(base64, name, duration);
        if (_ttsRapChat) _ttsRapChat.setAudio(base64, name, duration);
        updateTtsRefHints();
    };
    const onRemove = () => {
        state.ttsRefAudioData = null;
        state.ttsRefAudioName = '';
        state.ttsRefAudioDuration = 0;
        if (_ttsRapInit) _ttsRapInit.clear();
        if (_ttsRapChat) _ttsRapChat.clear();
        updateTtsRefHints();
    };

    const rapOpts = { theme: 'light', onUpload, onRemove };
    _ttsRapInit = new RefAudioPlayer(document.getElementById('ttsRefUploadInit'), rapOpts);
    _ttsRapChat = new RefAudioPlayer(document.getElementById('ttsRefUploadChat'), rapOpts);

    // åˆå§‹éªŒè¯æç¤º
    updateTtsRefHints();
}

// ============ å‘é€é¦–æ¡æ¶ˆæ¯ ============
/**
 * ä» UserContentEditor items æ„å»ºæœ€ç»ˆ content listï¼ˆå« base64 éŸ³é¢‘è½¬æ¢ï¼‰
 * @param {Array} items - editor.getItems() è¿”å›çš„ items
 * @returns {Promise<{content: string|Array, displayText: string, audioAttachments: Array}>}
 */
async function buildContentFromEditorItems(items) {
    // è¿‡æ»¤æœ‰æ•ˆ items
    const valid = items.filter(it => {
        if (it.type === 'text') return it.text && it.text.trim();
        if (it.type === 'audio') return it.data || it._blob || it.file || it.objectUrl;
        if (it.type === 'image') return it.data || it.file || it.objectUrl;
        return false;
    });

    if (valid.length === 0) return null;

    // è½¬æ¢éŸ³é¢‘ blob â†’ base64ï¼ˆ16kHz PCM float32ï¼‰
    for (const it of valid) {
        if (it.type !== 'audio' || it.data) continue;
        let source = it._blob || it.file;
        if (!source && it.objectUrl) {
            try { const r = await fetch(it.objectUrl); source = await r.blob(); } catch(e) { continue; }
        }
        if (source) {
            try { it.data = await convertToWav16k(source); it.name = it.name || 'audio'; } catch(e) { console.warn('Audio convert failed:', e); }
        }
    }

    // è½¬æ¢å›¾ç‰‡ file/blob â†’ base64ï¼ˆæ ‡å‡† base64 ç¼–ç ï¼‰
    for (const it of valid) {
        if (it.type !== 'image' || it.data) continue;
        let source = it.file;
        if (!source && it.objectUrl) {
            try { const r = await fetch(it.objectUrl); source = await r.blob(); } catch(e) { continue; }
        }
        if (source) {
            try {
                it.data = await blobToBase64(source);
                it.name = it.name || 'image';
            } catch(e) { console.warn('Image convert failed:', e); }
        }
    }

    // æ¸…ç†ä¸´æ—¶å­—æ®µ
    const cleaned = valid.map(it => {
        if (it.type === 'text') return { type: 'text', text: it.text };
        if (it.type === 'audio') return { type: 'audio', data: it.data, name: it.name, duration: it.duration };
        if (it.type === 'image') return { type: 'image', data: it.data, name: it.name };
        return it;
    }).filter(it => {
        if (it.type === 'audio') return !!it.data;
        if (it.type === 'image') return !!it.data;
        return true;
    });

    if (cleaned.length === 0) return null;

    const displayText = cleaned.filter(it => it.type === 'text').map(it => it.text).join('\n');
    const audioAttachments = cleaned.filter(it => it.type === 'audio' && it.data).map(it => ({ data: it.data, name: it.name || 'audio' }));

    // å¦‚æœåªæœ‰çº¯æ–‡æœ¬ï¼ˆæ— éŸ³é¢‘/å›¾ç‰‡ï¼‰ï¼Œcontent ç”¨å­—ç¬¦ä¸²æ ¼å¼ï¼ˆå…¼å®¹æ€§ï¼‰
    const hasMultimodal = cleaned.some(it => it.type === 'audio' || it.type === 'image');
    const content = hasMultimodal ? cleaned : (displayText || '');

    return { content, displayText, audioAttachments };
}

async function sendFirstMessage() {
    const editor = state.composeEditorInit;
    const items = editor.getItems();
    const result = await buildContentFromEditorItems(items);
    if (!result) return;

    // åˆ‡æ¢åˆ°å¯¹è¯è§†å›¾
    switchToConversation();

    // æ¸…ç©ºç¼–è¾‘å™¨
    editor.setItems([]);

    const { content, displayText, audioAttachments } = result;
    state.messages.push({ role: 'user', content, displayText, audioAttachments });
    addMessageUI('user', displayText, '', audioAttachments, state.messages.length - 1);

    // åˆ‡æ¢åä½¿ç”¨ chat è§†å›¾çš„å‚æ•°
    const mode = document.getElementById('modeSelect').value;
    const maxTokens = parseInt(document.getElementById('maxTokens').value) || 256;

    if (mode === 'chat') {
        sendChatMessage(maxTokens);
    } else {
        sendStreamingMessage(maxTokens);
    }
}

// ============ å‘é€æ¶ˆæ¯ï¼ˆå¯¹è¯è§†å›¾ï¼‰ ============
async function sendMessage() {
    if (state.isGenerating) return;

    const editor = state.composeEditorChat;
    const items = editor.getItems();
    const result = await buildContentFromEditorItems(items);
    if (!result) return;

    // æ¸…ç©ºç¼–è¾‘å™¨
    editor.setItems([]);

    const { content, displayText, audioAttachments } = result;
    state.messages.push({ role: 'user', content, displayText, audioAttachments });
    addMessageUI('user', displayText, '', audioAttachments, state.messages.length - 1);

    const mode = document.getElementById('modeSelect').value;
    const maxTokens = parseInt(document.getElementById('maxTokens').value) || 256;

    if (mode === 'chat') {
        await sendChatMessage(maxTokens);
    } else {
        await sendStreamingMessage(maxTokens);
    }
}

// ============ Chat æ¨¡å¼ ============
async function sendChatMessage(maxTokens) {
    setGenerating(true);
    state.generationPhase = 'queuing';
    updateCancelStopButton();
    addMessageUI('assistant', '...', '', [], -1);
    const reqId = state.requestId;

    const enableTts = getEnableTts();
    const requestStartTime = Date.now();

    // æ’é˜Ÿæ ‡è®°ï¼šç”± checkServiceStatus è½®è¯¢é©±åŠ¨å€’è®¡æ—¶ï¼ˆæ¯ 3sï¼‰
    _chatPending = true;

    state.abortController = new AbortController();

    try {
        const body = {
            messages: buildRequestMessages(),
            generation: { max_new_tokens: maxTokens, do_sample: true },
            image: { max_slice_nums: getHDMaxSliceNums() },
        };

        if (enableTts) {
            const tts = {
                enabled: true,
                mode: 'audio_assistant',
            };
            // TTS ref audioï¼ˆä» TTS Ref Audio æ§ä»¶è·å–ï¼Œå¯èƒ½ç‹¬ç«‹äºç³»ç»Ÿ prompt ä¸­çš„ audioï¼‰
            const chatRefAudio = getTtsRefAudioBase64();
            if (chatRefAudio) {
                tts.ref_audio_data = chatRefAudio;
            }
            body.tts = tts;
            body.use_tts_template = true;
        }

        const resp = await fetch(`${API_BASE}/api/chat`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body),
            signal: state.abortController.signal,
        });

        const data = await resp.json();

        if (data.success) {
            if (data.recording_session_id && typeof _saveShareUI !== 'undefined') {
                _saveShareUI.setSessionId(data.recording_session_id);
            }
            const totalWaitMs = Date.now() - requestStartTime;
            state.messages.push({ role: 'assistant', content: data.text, displayText: data.text });
            updateLastAssistantMessage(data.text);
            const ts = data.token_stats || {};
            updateLastAssistantMeta({
                mode: 'chat',
                totalMs: totalWaitMs,
                queueEstS: data.estimated_queue_wait_s ?? null,
                queueActualMs: data.queue_wait_ms ?? null,
                processMs: Math.round(data.duration_ms || 0),
                inputTokens: ts.input_tokens || 0,
                generatedTokens: ts.generated_tokens || 0,
                hasAudio: !!data.audio_data,
                requestId: reqId,
            });
            // æ›´æ–° edit æŒ‰é’®
            const lastMsg = document.querySelectorAll('.message.assistant');
            const last = lastMsg[lastMsg.length - 1];
            if (last) {
                last.dataset.msgIndex = state.messages.length - 1;
                if (!last.querySelector('.msg-edit-btn')) {
                    const editBtn = document.createElement('span');
                    editBtn.className = 'msg-edit-btn';
                    editBtn.textContent = 'Edit';
                    editBtn.onclick = () => startEditMessage(state.messages.length - 1);
                    last.appendChild(editBtn);
                }
            }

            if (data.audio_data) {
                appendAudioPlayer(data.audio_data);
            }
        } else {
            updateLastAssistantMessage(`Error: ${data.error}`, 'error');
        }
    } catch (e) {
        if (e.name === 'AbortError') return; // cancelled by user
        updateLastAssistantMessage(`Network error: ${e.message}`, 'error');
    } finally {
        state.abortController = null;
        queueCountdownStop();
        setGenerating(false);
    }
}

function getEnableTts() {
    if (state.currentView === 'initial') {
        return document.getElementById('enableTtsInit').checked;
    }
    return document.getElementById('enableTts').checked;
}

function getHDMaxSliceNums() {
    const el = state.currentView === 'initial'
        ? document.getElementById('enableHDInit')
        : document.getElementById('enableHD');
    return el && el.checked ? 2 : 1;
}

// ============ æµå¼éŸ³é¢‘æ’­æ”¾å™¨ ============
class StreamingAudioPlayer {
    constructor(sampleRate = 24000) {
        this.sampleRate = sampleRate;
        this.audioCtx = getSharedAudioCtx();
        this.chunks = [];
        this.totalSamples = 0;
        this.isPlaying = false;
        this.currentTime = 0;
        this.domElement = null;
        this.streamFinished = false;
        this._rafId = null;
        this._nextScheduleTime = 0;
        this._playOriginWall = 0;
        this._playOriginOffset = 0;
        this._scheduledSources = [];
        this._lastScheduledIdx = -1;
    }

    get totalDuration() { return this.totalSamples / this.sampleRate; }

    get playbackTime() {
        if (!this.isPlaying) return this.currentTime;
        const elapsed = this.audioCtx.currentTime - this._playOriginWall;
        const scheduledEnd = this._nextScheduleTime - this._playOriginWall;
        const effectiveElapsed = Math.min(elapsed, scheduledEnd);
        return Math.min(this._playOriginOffset + effectiveElapsed, this.totalDuration);
    }

    pushChunk(base64Float32Pcm, spanId) {
        const binary = atob(base64Float32Pcm);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
        const float32 = new Float32Array(bytes.buffer);
        if (float32.length === 0) return;
        const startTime = this.totalSamples / this.sampleRate;
        const duration = float32.length / this.sampleRate;
        this.chunks.push({ float32, startTime, duration, spanId });
        this.totalSamples += float32.length;
        if (this.isPlaying) this._scheduleChunk(this.chunks.length - 1);
        this._updateUI();
    }

    _scheduleChunk(idx) {
        const chunk = this.chunks[idx];
        const buf = this.audioCtx.createBuffer(1, chunk.float32.length, this.sampleRate);
        buf.getChannelData(0).set(chunk.float32);
        const src = this.audioCtx.createBufferSource();
        src.buffer = buf;
        src.connect(this.audioCtx.destination);
        const now = this.audioCtx.currentTime;
        const when = Math.max(now, this._nextScheduleTime);
        src.start(when);
        this._nextScheduleTime = when + buf.duration;
        this._lastScheduledIdx = idx;
        src.onended = () => {
            const i = this._scheduledSources.indexOf(src);
            if (i >= 0) this._scheduledSources.splice(i, 1);
            if (this._scheduledSources.length === 0 && this.isPlaying) {
                if (this._lastScheduledIdx >= this.chunks.length - 1) {
                    this.currentTime = this.totalDuration;
                    if (this.streamFinished) { this.isPlaying = false; this._stopUILoop(); }
                    this._updateUI();
                }
            }
        };
        this._scheduledSources.push(src);
    }

    play(fromOffset = null) {
        this._stopAllSources();
        if (fromOffset !== null) this.currentTime = fromOffset;
        // æ’­æ”¾ç»“æŸåé‡æ–°ç‚¹å‡»ï¼šä»å¤´å¼€å§‹ï¼ˆè€Œé returnï¼‰
        if (this.currentTime >= this.totalDuration && this.streamFinished) {
            this.currentTime = 0;
        }
        if (this.totalDuration === 0) return; // æ— å†…å®¹å¯æ’­
        const offset = this.currentTime;
        if (this.audioCtx.state === 'suspended') this.audioCtx.resume();
        this._playOriginWall = this.audioCtx.currentTime;
        this._playOriginOffset = offset;
        this._nextScheduleTime = this.audioCtx.currentTime;
        this.isPlaying = true;
        let started = false;
        for (let i = 0; i < this.chunks.length; i++) {
            const c = this.chunks[i];
            const cEnd = c.startTime + c.duration;
            if (cEnd <= offset) continue;
            if (!started && c.startTime < offset) {
                const skipSamples = Math.floor((offset - c.startTime) * this.sampleRate);
                const remaining = c.float32.subarray(skipSamples);
                if (remaining.length > 0) {
                    const buf = this.audioCtx.createBuffer(1, remaining.length, this.sampleRate);
                    buf.getChannelData(0).set(remaining);
                    const src = this.audioCtx.createBufferSource();
                    src.buffer = buf;
                    src.connect(this.audioCtx.destination);
                    src.start(this._nextScheduleTime);
                    this._nextScheduleTime += buf.duration;
                    this._scheduledSources.push(src);
                    this._lastScheduledIdx = i;
                }
                started = true;
            } else {
                this._scheduleChunk(i);
                started = true;
            }
        }
        this._startUILoop();
    }

    pause() {
        if (!this.isPlaying) return;
        this.currentTime = this.playbackTime;
        this._stopAllSources();
        this.isPlaying = false;
        this._stopUILoop();
        this._updateUI();
    }

    _stopAllSources() {
        for (const src of this._scheduledSources) {
            try { src.onended = null; src.stop(); } catch(e) {}
        }
        this._scheduledSources = [];
    }

    seek(time) {
        const wasPlaying = this.isPlaying;
        if (wasPlaying) this._stopAllSources();
        this.currentTime = Math.max(0, Math.min(time, this.totalDuration));
        this.isPlaying = false;
        if (wasPlaying) this.play();
        this._updateUI();
    }

    togglePlay() { if (this.isPlaying) this.pause(); else this.play(); }
    markStreamFinished() { this.streamFinished = true; this._updateUI(); }

    getFullFloat32() {
        if (this.chunks.length === 0) return null;
        const merged = new Float32Array(this.totalSamples);
        let offset = 0;
        for (const chunk of this.chunks) { merged.set(chunk.float32, offset); offset += chunk.float32.length; }
        return merged;
    }

    _fmtTime(s) {
        if (!isFinite(s) || s < 0) s = 0;
        return `${Math.floor(s/60)}:${Math.floor(s%60).toString().padStart(2,'0')}`;
    }

    createControl() {
        const wrap = document.createElement('div');
        wrap.className = 'audio-ctrl';
        wrap.innerHTML = `
            <button class="ac-play" data-ac="toggle">â–¶</button>
            <div class="ac-bar" data-ac="bar">
                <div class="ac-bar-fill"></div>
                <div class="ac-bar-dot" style="left:0"></div>
            </div>
            <span class="ac-time" data-ac="time">0:00 / 0:00</span>
        `;
        wrap.querySelector('[data-ac="toggle"]').onclick = () => this.togglePlay();
        const bar = wrap.querySelector('[data-ac="bar"]');
        const doSeek = (e) => {
            const r = bar.getBoundingClientRect();
            this.seek(Math.max(0, Math.min(1, (e.clientX - r.left) / r.width)) * this.totalDuration);
        };
        bar.addEventListener('mousedown', (e) => {
            doSeek(e);
            const mv = (e2) => doSeek(e2);
            const up = () => { document.removeEventListener('mousemove', mv); document.removeEventListener('mouseup', up); };
            document.addEventListener('mousemove', mv);
            document.addEventListener('mouseup', up);
        });
        this.domElement = wrap;
        wrap._streamingPlayer = this;
        return wrap;
    }

    _updateUI() {
        if (!this.domElement) return;
        const t = this.playbackTime;
        const total = this.totalDuration;
        const pct = total > 0 ? Math.min(t / total * 100, 100) : 0;
        this.domElement.querySelector('[data-ac="toggle"]').textContent = this.isPlaying ? 'â¸' : 'â–¶';
        this.domElement.querySelector('[data-ac="time"]').textContent = `${this._fmtTime(t)} / ${this._fmtTime(total)}`;
        this.domElement.querySelector('.ac-bar-fill').style.width = `${pct}%`;
        this.domElement.querySelector('.ac-bar-dot').style.left = `${pct}%`;
        const stopBtn = this.domElement.querySelector('[data-ac="stop"]');
        if (stopBtn) stopBtn.style.display = this.streamFinished ? 'none' : '';
    }

    _startUILoop() {
        this._stopUILoop();
        const tick = () => { if (!this.isPlaying) return; this._updateUI(); this._rafId = requestAnimationFrame(tick); };
        this._rafId = requestAnimationFrame(tick);
    }
    _stopUILoop() { if (this._rafId) { cancelAnimationFrame(this._rafId); this._rafId = null; } }
}

function mergeAudioChunksToWav(chunks, sampleRate) {
    const float32Arrays = chunks.map(b64 => {
        const binary = atob(b64);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
        return new Float32Array(bytes.buffer);
    });
    const totalLength = float32Arrays.reduce((sum, arr) => sum + arr.length, 0);
    const merged = new Float32Array(totalLength);
    let offset = 0;
    for (const arr of float32Arrays) { merged.set(arr, offset); offset += arr.length; }
    const int16 = new Int16Array(merged.length);
    for (let i = 0; i < merged.length; i++) {
        const s = Math.max(-1, Math.min(1, merged[i]));
        int16[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
    }
    const wavBuffer = new ArrayBuffer(44 + int16.length * 2);
    const view = new DataView(wavBuffer);
    const writeString = (offset, str) => { for (let i = 0; i < str.length; i++) view.setUint8(offset + i, str.charCodeAt(i)); };
    writeString(0, 'RIFF');
    view.setUint32(4, 36 + int16.length * 2, true);
    writeString(8, 'WAVE'); writeString(12, 'fmt ');
    view.setUint32(16, 16, true); view.setUint16(20, 1, true); view.setUint16(22, 1, true);
    view.setUint32(24, sampleRate, true); view.setUint32(28, sampleRate * 2, true);
    view.setUint16(32, 2, true); view.setUint16(34, 16, true);
    writeString(36, 'data'); view.setUint32(40, int16.length * 2, true);
    new Int16Array(wavBuffer, 44).set(int16);
    const wavBytes = new Uint8Array(wavBuffer);
    let binary = '';
    for (let i = 0; i < wavBytes.length; i++) binary += String.fromCharCode(wavBytes[i]);
    return btoa(binary);
}

// ============ ä¸‹è½½ / å¯¼å‡ºå·¥å…· ============

const DL_ICON_SVG = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>';

function createDlBtn(onclick) {
    const btn = document.createElement('button');
    btn.className = 'dl-btn';
    btn.title = 'Download';
    btn.innerHTML = DL_ICON_SVG;
    btn.addEventListener('click', (e) => { e.stopPropagation(); onclick(); });
    return btn;
}

function triggerDownload(blob, filename) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = filename;
    document.body.appendChild(a); a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

/**
 * Float32Array PCM â†’ WAV Uint8Array (16-bit PCM)
 */
function float32ToWavBytes(float32, sampleRate) {
    const int16 = new Int16Array(float32.length);
    for (let i = 0; i < float32.length; i++) {
        const s = Math.max(-1, Math.min(1, float32[i]));
        int16[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
    }
    const buf = new ArrayBuffer(44 + int16.length * 2);
    const v = new DataView(buf);
    const ws = (off, str) => { for (let i = 0; i < str.length; i++) v.setUint8(off + i, str.charCodeAt(i)); };
    ws(0, 'RIFF'); v.setUint32(4, 36 + int16.length * 2, true);
    ws(8, 'WAVE'); ws(12, 'fmt ');
    v.setUint32(16, 16, true); v.setUint16(20, 1, true); v.setUint16(22, 1, true);
    v.setUint32(24, sampleRate, true); v.setUint32(28, sampleRate * 2, true);
    v.setUint16(32, 2, true); v.setUint16(34, 16, true);
    ws(36, 'data'); v.setUint32(40, int16.length * 2, true);
    new Int16Array(buf, 44).set(int16);
    return new Uint8Array(buf);
}

function downloadAudioBuffer(audioBuffer, filename) {
    const pcm = audioBuffer.getChannelData(0);
    const wavBytes = float32ToWavBytes(pcm, audioBuffer.sampleRate);
    triggerDownload(new Blob([wavBytes], { type: 'audio/wav' }), filename);
}

function downloadFloat32AsWav(float32, sampleRate, filename) {
    const wavBytes = float32ToWavBytes(float32, sampleRate);
    triggerDownload(new Blob([wavBytes], { type: 'audio/wav' }), filename);
}

function downloadBase64AsFile(base64Data, filename, mimeType) {
    const raw = atob(base64Data);
    const bytes = new Uint8Array(raw.length);
    for (let i = 0; i < raw.length; i++) bytes[i] = raw.charCodeAt(i);
    triggerDownload(new Blob([bytes], { type: mimeType }), filename);
}

function base64ToUint8Array(b64) {
    const raw = atob(b64);
    const arr = new Uint8Array(raw.length);
    for (let i = 0; i < raw.length; i++) arr[i] = raw.charCodeAt(i);
    return arr;
}

/**
 * å¯¼å‡ºæ•´ä¸ªå¯¹è¯ä¸º .msgpack æ–‡ä»¶ï¼ˆå…¼å®¹ msgpack-audio-viewerï¼‰
 *
 * æ ¼å¼ï¼š
 * { messages: [ { role, content: [ { type, text?, audio?, image?, format? } ] } ] }
 * å…¶ä¸­ audio/image å­—æ®µä¸ºåŸå§‹ bytes (Uint8Array)
 */
async function exportConversation() {
    const { encode } = await import('/static/lib/msgpack.mjs');

    const exportMessages = [];
    const messageDivs = document.querySelectorAll('#messages .message');
    const divByIndex = {};
    messageDivs.forEach(d => { divByIndex[d.dataset.msgIndex] = d; });

    // System message
    if (state.systemContentList && state.systemContentList.length > 0) {
        const items = [];
        for (const it of state.systemContentList) {
            if (it.type === 'text' && it.text) {
                items.push({ type: 'text', text: it.text });
            } else if (it.type === 'audio' && it.data) {
                const pcm = base64ToUint8Array(it.data);
                const f32 = new Float32Array(pcm.buffer);
                items.push({ type: 'audio', audio: float32ToWavBytes(f32, 16000), format: 'wav' });
            }
        }
        if (items.length > 0) exportMessages.push({ role: 'system', content: items });
    }

    // Conversation messages
    for (let i = 0; i < state.messages.length; i++) {
        const msg = state.messages[i];
        const div = divByIndex[String(i)];
        const items = [];

        if (msg.role === 'user') {
            if (Array.isArray(msg.content)) {
                for (const it of msg.content) {
                    if (it.type === 'text' && it.text) {
                        items.push({ type: 'text', text: it.text });
                    } else if (it.type === 'audio' && it.data) {
                        const pcm = base64ToUint8Array(it.data);
                        const f32 = new Float32Array(pcm.buffer);
                        items.push({ type: 'audio', audio: float32ToWavBytes(f32, 16000), format: 'wav' });
                    } else if (it.type === 'image' && it.data) {
                        items.push({ type: 'image', image: base64ToUint8Array(it.data), format: 'png' });
                    }
                }
            } else if (typeof msg.content === 'string' && msg.content) {
                items.push({ type: 'text', text: msg.content });
            }
        } else if (msg.role === 'assistant') {
            let audioWavBytes = null;
            if (div) {
                const miniPlayer = div.querySelector('.mini-player');
                if (miniPlayer && miniPlayer._audioBuffer) {
                    const buf = miniPlayer._audioBuffer;
                    audioWavBytes = float32ToWavBytes(buf.getChannelData(0), buf.sampleRate);
                }
                if (!audioWavBytes) {
                    const audioCtrl = div.querySelector('.audio-ctrl');
                    if (audioCtrl && audioCtrl._streamingPlayer) {
                        const sp = audioCtrl._streamingPlayer;
                        const f32 = sp.getFullFloat32();
                        if (f32) audioWavBytes = float32ToWavBytes(f32, sp.sampleRate);
                    }
                }
            }
            if (msg.displayText && audioWavBytes) {
                items.push({ type: 'text_and_audio', text: msg.displayText, audio: audioWavBytes, format: 'wav' });
            } else if (msg.displayText) {
                items.push({ type: 'text', text: msg.displayText });
            } else if (audioWavBytes) {
                items.push({ type: 'text_and_audio', text: '', audio: audioWavBytes, format: 'wav' });
            }
        }

        if (items.length > 0) exportMessages.push({ role: msg.role, content: items });
    }

    if (exportMessages.length === 0) { alert('No messages to export.'); return; }

    const encoded = encode({ messages: exportMessages });
    const ts = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
    triggerDownload(new Blob([encoded], { type: 'application/x-msgpack' }), `conversation_${ts}.msgpack`);
}

/**
 * å…¨å±€å…±äº« AudioContextï¼ˆé¿å…æµè§ˆå™¨ AudioContext æ•°é‡é™åˆ¶å¯¼è‡´æ’­æ”¾å¤±è´¥ï¼‰
 */
let _sharedAudioCtx = null;
function getSharedAudioCtx() {
    if (!_sharedAudioCtx || _sharedAudioCtx.state === 'closed') {
        _sharedAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    return _sharedAudioCtx;
}

/**
 * åˆ›å»ºè¿·ä½ éŸ³é¢‘æ’­æ”¾å™¨
 * @param {string} audioBase64 - base64 ç¼–ç çš„éŸ³é¢‘æ•°æ®
 * @param {number} [rawPcmSampleRate=24000] - å½“æ•°æ®ä¸º raw PCM float32 æ—¶ä½¿ç”¨çš„é‡‡æ ·ç‡
 *   User å½•éŸ³ = 16000, AI TTS streaming = 24000, AI chat = WAVæ ¼å¼(è‡ªåŠ¨è§£æ)
 */
function createMiniPlayer(audioBase64, rawPcmSampleRate = 24000) {
    const wrap = document.createElement('div');
    wrap.className = 'mini-player';
    const btn = document.createElement('button'); btn.className = 'mp-btn'; btn.textContent = 'â–¶';
    const bar = document.createElement('div'); bar.className = 'mp-bar';
    const barFill = document.createElement('div'); barFill.className = 'mp-bar-fill';
    const barDot = document.createElement('div'); barDot.className = 'mp-bar-dot'; barDot.style.left = '0';
    bar.appendChild(barFill); bar.appendChild(barDot);
    const timeEl = document.createElement('span'); timeEl.className = 'mp-time'; timeEl.textContent = '0:00';
    wrap.appendChild(btn); wrap.appendChild(bar); wrap.appendChild(timeEl);

    const audioCtx = getSharedAudioCtx();
    const raw = atob(audioBase64);
    const bytes = new Uint8Array(raw.length);
    for (let i = 0; i < raw.length; i++) bytes[i] = raw.charCodeAt(i);
    let audioBuffer = null, source = null, isPlaying = false, startWall = 0, startOffset = 0, raf = null;
    const fmt = (s) => `${Math.floor(s/60)}:${Math.floor(s%60).toString().padStart(2,'0')}`;

    // å°è¯•ä½œä¸º WAV/æ ‡å‡†æ ¼å¼è§£ç ï¼ˆChat æ¨¡å¼è¿”å› WAVï¼‰ï¼Œå¤±è´¥åˆ™æŒ‰ raw PCM float32 å¤„ç†
    audioCtx.decodeAudioData(bytes.buffer.slice(0)).then(buf => {
        audioBuffer = buf; timeEl.textContent = `0:00 / ${fmt(buf.duration)}`;
        wrap._audioBuffer = buf;
    }).catch(() => {
        const float32 = new Float32Array(bytes.buffer);
        audioBuffer = audioCtx.createBuffer(1, float32.length, rawPcmSampleRate);
        audioBuffer.getChannelData(0).set(float32);
        timeEl.textContent = `0:00 / ${fmt(audioBuffer.duration)}`;
        wrap._audioBuffer = audioBuffer;
    });

    function getTime() { return isPlaying ? Math.min(startOffset + (audioCtx.currentTime - startWall), audioBuffer ? audioBuffer.duration : 0) : startOffset; }
    function play(from) {
        stopSource(); if (!audioBuffer) return;
        // ç¡®ä¿ AudioContext æœªè¢«æµè§ˆå™¨ suspendï¼ˆéœ€è¦ç”¨æˆ·äº¤äº’åæ¢å¤ï¼‰
        if (audioCtx.state === 'suspended') audioCtx.resume();
        if (from !== undefined) startOffset = from;
        if (startOffset >= audioBuffer.duration) startOffset = 0;
        source = audioCtx.createBufferSource(); source.buffer = audioBuffer; source.connect(audioCtx.destination);
        source.onended = () => { if (isPlaying) { startOffset = audioBuffer.duration; isPlaying = false; updateUI(); } };
        source.start(0, startOffset); startWall = audioCtx.currentTime; isPlaying = true; tick();
    }
    function stopSource() { if (source) { try { source.onended = null; source.stop(); } catch(e) {} source = null; } isPlaying = false; if (raf) { cancelAnimationFrame(raf); raf = null; } }
    function toggle() { if (isPlaying) { startOffset = getTime(); stopSource(); updateUI(); } else play(); }
    function updateUI() {
        const t = getTime(); const dur = audioBuffer ? audioBuffer.duration : 0; const pct = dur > 0 ? (t / dur) * 100 : 0;
        btn.textContent = isPlaying ? 'â¸' : 'â–¶'; barFill.style.width = `${pct}%`; barDot.style.left = `${pct}%`;
        timeEl.textContent = `${fmt(t)} / ${fmt(dur)}`;
    }
    function tick() { if (!isPlaying) return; updateUI(); raf = requestAnimationFrame(tick); }
    btn.onclick = toggle;
    bar.addEventListener('mousedown', (e) => {
        if (!audioBuffer) return;
        const doSeek = (ev) => { const r = bar.getBoundingClientRect(); play(Math.max(0, Math.min(1, (ev.clientX - r.left) / r.width)) * audioBuffer.duration); };
        doSeek(e);
        const mv = (ev) => doSeek(ev); const up = () => { document.removeEventListener('mousemove', mv); document.removeEventListener('mouseup', up); };
        document.addEventListener('mousemove', mv); document.addEventListener('mouseup', up);
    });
    return wrap;
}

function appendAudioPlayer(audioBase64) {
    const msgs = document.querySelectorAll('.message.assistant');
    const last = msgs[msgs.length - 1];
    if (!last) return;
    const body = last.querySelector('.msg-body');
    const wrap = document.createElement('div');
    wrap.className = 'msg-ci-audio';
    wrap.appendChild(createMiniPlayer(audioBase64));
    const dlBtn = createDlBtn(() => {
        const mp = wrap.querySelector('.mini-player');
        if (mp && mp._audioBuffer) downloadAudioBuffer(mp._audioBuffer, 'ai_audio.wav');
    });
    wrap.appendChild(dlBtn);
    body.appendChild(wrap);
}

function appendStreamingAudioControl(player) {
    const msgs = document.querySelectorAll('.message.assistant');
    const last = msgs[msgs.length - 1];
    if (!last) return;
    const body = last.querySelector('.msg-body');
    const wrap = document.createElement('div');
    wrap.className = 'msg-ci-audio';
    wrap.appendChild(player.createControl());
    const dlBtn = createDlBtn(() => {
        const f32 = player.getFullFloat32();
        if (f32) downloadFloat32AsWav(f32, player.sampleRate, 'ai_audio.wav');
    });
    wrap.appendChild(dlBtn);
    body.appendChild(wrap);
}

// ============ Streaming æ¨¡å¼ ============
async function sendStreamingMessage(maxTokens) {
    setGenerating(true);
    state.generationPhase = 'queuing';
    updateCancelStopButton();
    addMessageUI('assistant', '', '', [], -1);
    const reqId = state.requestId;

    try {
        const wsProto = location.protocol === 'https:' ? 'wss' : 'ws';
        const ws = new WebSocket(`${wsProto}://${window.location.host}/ws/streaming/${reqId}`);
        state.streamingWs = ws;

        ws.onopen = () => {
            // æ„å»ºå®Œæ•´æ¶ˆæ¯å†å²ï¼ˆå« systemï¼‰
            const allMessages = buildRequestMessages();

            const prefillMsg = {
                type: 'prefill',
                session_id: reqId,
                messages: allMessages,
                is_last_chunk: true,
                max_slice_nums: getHDMaxSliceNums(),
            };

            // TTS ref audioï¼ˆç‹¬ç«‹äºç³»ç»Ÿ prompt ä¸­çš„ LLM ref audioï¼‰
            const streamRefAudio = getTtsRefAudioBase64();
            if (streamRefAudio) {
                prefillMsg.tts_ref_audio_base64 = streamRefAudio;
            }

            ws.send(JSON.stringify(prefillMsg));
        };

        let fullText = '';
        const startTime = Date.now();
        let ttfsTime = null;  // time to first stream chunk (absolute, from startTime)
        let queueDoneTime = null;  // when worker was assigned
        let firstEstimatedWaitS = null;  // first estimated queue wait from backend
        let prefillInfo = {};  // cached_tokens, input_tokens from prefill_done
        const enableTts = getEnableTts();
        let streamAudioPlayer = null;
        let controlCreated = false;

        if (enableTts) {
            streamAudioPlayer = new StreamingAudioPlayer(24000);
        }

        ws.onmessage = (event) => {
            const msg = JSON.parse(event.data);

            // Queue messages from gateway â€” é©±åŠ¨å€’è®¡æ—¶ + è®°å½•æ—¶é—´æˆ³
            if (msg.type === 'queued' || msg.type === 'queue_update') {
                if (msg.type === 'queued' && msg.ticket_id) {
                    state.currentTicketId = msg.ticket_id;
                }
                state.generationPhase = 'queuing';
                updateCancelStopButton();
                if (firstEstimatedWaitS === null) firstEstimatedWaitS = msg.estimated_wait_s;
                queueCountdownUpdate(msg.estimated_wait_s, msg.position, msg.queue_length || null);
                return;
            }
            if (msg.type === 'queue_done') {
                state.generationPhase = 'generating';
                state.currentTicketId = null;
                updateCancelStopButton();
                queueDoneTime = Date.now();
                queueCountdownStop('Worker assigned, processing...');
                return;
            }

            if (msg.type === 'prefill_done') {
                if (state.generationPhase !== 'generating') {
                    state.generationPhase = 'generating';
                    updateCancelStopButton();
                }
                prefillInfo = { cachedTokens: msg.cached_tokens || 0, inputTokens: msg.input_tokens || 0 };
                if (msg.recording_session_id && typeof _saveShareUI !== 'undefined') {
                    _saveShareUI.setSessionId(msg.recording_session_id);
                }
                ws.send(JSON.stringify({
                    type: 'generate',
                    session_id: reqId,
                    generate_audio: enableTts,
                    max_new_tokens: maxTokens,
                    length_penalty: parseFloat(document.getElementById('lengthPenalty').value) || 1.1,
                }));
            } else if (msg.type === 'chunk') {
                if (ttfsTime === null) ttfsTime = Date.now() - startTime;
                if (msg.text_delta) { fullText += msg.text_delta; updateLastAssistantMessage(fullText); }
                if (msg.audio_data && streamAudioPlayer) {
                    streamAudioPlayer.pushChunk(msg.audio_data, null);
                    if (!controlCreated) { appendStreamingAudioControl(streamAudioPlayer); streamAudioPlayer.play(0); controlCreated = true; }
                }
            } else if (msg.type === 'done') {
                const elapsed = Date.now() - startTime;
                const queueMs = queueDoneTime ? (queueDoneTime - startTime) : 0;
                state.messages.push({ role: 'assistant', content: fullText, displayText: fullText });
                const ts = msg.token_stats || {};
                updateLastAssistantMeta({
                    mode: 'streaming',
                    totalMs: elapsed,
                    queueEstS: firstEstimatedWaitS,
                    queueActualMs: queueMs,
                    ttfsMs: ttfsTime != null ? Math.max(0, ttfsTime - queueMs) : null,
                    processMs: elapsed - queueMs,
                    inputTokens: ts.input_tokens || prefillInfo.inputTokens || 0,
                    cachedTokens: ts.cached_tokens || prefillInfo.cachedTokens || 0,
                    generatedTokens: ts.generated_tokens || 0,
                    chunks: streamAudioPlayer ? streamAudioPlayer.chunks.length : 0,
                    stopped: msg.stopped,
                    requestId: reqId,
                });
                if (streamAudioPlayer) streamAudioPlayer.markStreamFinished();
                // KV cache limit check
                const totalTokens = ts.total_tokens || ((ts.input_tokens || 0) + (ts.generated_tokens || 0));
                const maxKv = getMaxKvTokens();
                if (totalTokens >= maxKv) {
                    addMessageUI('assistant',
                        `âš  KV cache (${totalTokens.toLocaleString()} tokens) has reached the limit (${maxKv.toLocaleString()}). Consider starting a new conversation to avoid degraded quality.`,
                        '', [], -1);
                    state.messages.push({ role: 'assistant', content: `[KV limit warning: ${totalTokens}/${maxKv}]`, displayText: '' });
                }
                // æ›´æ–° edit æŒ‰é’®
                const lastMsg = document.querySelectorAll('.message.assistant');
                const last = lastMsg[lastMsg.length - 1];
                if (last) {
                    last.dataset.msgIndex = state.messages.length - 1;
                    if (!last.querySelector('.msg-edit-btn')) {
                        const editBtn = document.createElement('span');
                        editBtn.className = 'msg-edit-btn';
                        editBtn.textContent = 'Edit';
                        editBtn.onclick = () => startEditMessage(state.messages.length - 1);
                        last.appendChild(editBtn);
                    }
                }
                ws.close();
                setGenerating(false);
            } else if (msg.type === 'error') {
                updateLastAssistantMessage(`Error: ${msg.error}`, 'error');
                ws.close();
                setGenerating(false);
            }
        };

        ws.onerror = () => { state.streamingWs = null; queueCountdownStop(); updateLastAssistantMessage('WebSocket error', 'error'); setGenerating(false); };
        ws.onclose = () => { state.streamingWs = null; queueCountdownStop(); if (state.isGenerating) setGenerating(false); };

    } catch (e) {
        queueCountdownStop();
        updateLastAssistantMessage(`Connection error: ${e.message}`, 'error');
        setGenerating(false);
    }
}

// ============ å¯åŠ¨ ============
init();
</script>

<!-- Save & Share -->
<div id="save-share-container" style="position:fixed;bottom:16px;right:16px;z-index:100;max-width:300px;"></div>
<script src="/static/shared/save-share.js"></script>
<script>
const _saveShareUI = new SaveShareUI({ containerId: 'save-share-container', appType: 'streaming' });
</script>
</body>
</html>
